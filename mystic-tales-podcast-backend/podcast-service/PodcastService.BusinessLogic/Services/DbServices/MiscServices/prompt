// using PodcastService.BusinessLogic.DTOs.Show;
// using PodcastService.BusinessLogic.DTOs.Account;
// using PodcastService.BusinessLogic.DTOs.Episode;
// using PodcastService.BusinessLogic.DTOs.Channel;
// using PodcastService.BusinessLogic.DTOs.Category;
// using PodcastService.BusinessLogic.DTOs.Show.ListItems;
// using PodcastService.BusinessLogic.DTOs.Channel.ListItems;
// using PodcastService.BusinessLogic.DTOs.Category.ListItems;

// namespace PodcastService.BusinessLogic.DTOs.Feed;

// public class DiscoveryPodcastFeedDTO
// {
//     public required ContinueListeningDiscoveryPodcastFeedSection ContinueListening { get; set; }
//     public required BasedOnYourTasteDiscoveryPodcastFeedSection BasedOnYourTaste { get; set; }
//     public required NewReleasesDiscoveryPodcastFeedSection NewReleases { get; set; }
//     public required HotThisWeekDiscoveryPodcastFeedSection HotThisWeek { get; set; }
//     public required TopSubCategoryDiscoveryPodcastFeedSection TopSubCategory { get; set; }
//     public required TopPodcastersDiscoveryPodcastFeedSection TopPodcasters { get; set; }
//     public required RandomCategoryDiscoveryPodcastFeedSection RandomCategory { get; set; }
//     public required TalentedRookiesDiscoveryPodcastFeedSection TalentedRookies { get; set; }

//     public class ContinueListeningDiscoveryPodcastFeedSection
//     {
//         public required List<ListenSessionDiscoveryPodcastFeedListItem> ListenSessionList { get; set; }
//     }

//     public class ListenSessionDiscoveryPodcastFeedListItem
//     {
//         public PodcastEpisodeSnippetResponseDTO? Episode { get; set; }
//         public AccountSnippetResponseDTO? Podcaster { get; set; }
//         public required PodcastEpisodeListenSessionSnippetResponseDTO? PodcastEpisodeListenSession { get; set; }
//     }

//     public class BasedOnYourTasteDiscoveryPodcastFeedSection
//     {
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class NewReleasesDiscoveryPodcastFeedSection
//     {
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class HotThisWeekDiscoveryPodcastFeedSection
//     {
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//         public List<ChannelListItemResponseDTO>? ChannelList { get; set; }
//     }

//     public class TopSubCategoryDiscoveryPodcastFeedSection
//     {
//         public PodcastSubCategoryListItemResponseDTO? PodcastSubCategory { get; set; }
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class TopPodcastersDiscoveryPodcastFeedSection
//     {
//         public List<AccountSnippetResponseDTO>? PodcasterList { get; set; }
//     }

//     public class RandomCategoryDiscoveryPodcastFeedSection
//     {
//         public required PodcastCategoryDTO PodcastCategory { get; set; }
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class TalentedRookiesDiscoveryPodcastFeedSection
//     {
//         public List<AccountSnippetResponseDTO>? PodcasterList { get; set; }
//     }
// }

// using PodcastService.BusinessLogic.DTOs.Show.ListItems;
// using PodcastService.BusinessLogic.DTOs.Channel.ListItems;
// using PodcastService.BusinessLogic.DTOs.Category;
// using PodcastService.BusinessLogic.DTOs.Account;
// using PodcastService.BusinessLogic.DTOs.Episode;

// namespace PodcastService.BusinessLogic.DTOs.Feed;

// public class TrendingPodcastFeedDTO
// {
//     public required PopularPodcastersTrendingPodcastFeedSection PopularPodcasters { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category1 { get; set; }
//     public required HotPodcastersTrendingPodcastFeedSection HotPodcasters { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category2 { get; set; }
//     public required PopularChannelsTrendingPodcastFeedSection PopularChannels { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category3 { get; set; }
//     public required HotChannelsTrendingPodcastFeedSection HotChannels { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category4 { get; set; }
//     public required PopularShowsTrendingPodcastFeedSection PopularShows { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category5 { get; set; }
//     public required HotShowsTrendingPodcastFeedSection HotShows { get; set; }
//     public required CategoryTrendingPodcastFeedSection Category6 { get; set; }
//     public required NewEpisodesTrendingPodcastFeedSection NewEpisodes { get; set; }
//     public required PopularEpisodesTrendingPodcastFeedSection PopularEpisodes { get; set; }

//     public class PopularPodcastersTrendingPodcastFeedSection
//     {
//         public List<AccountSnippetResponseDTO>? PodcasterList { get; set; }
//     }

//     public class CategoryTrendingPodcastFeedSection
//     {
//         public PodcastCategoryDTO? PodcastCategory { get; set; }
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class HotPodcastersTrendingPodcastFeedSection
//     {
//         public List<AccountSnippetResponseDTO>? PodcasterList { get; set; }
//     }

//     public class PopularChannelsTrendingPodcastFeedSection
//     {
//         public List<ChannelListItemResponseDTO>? ChannelList { get; set; }
//     }

//     public class HotChannelsTrendingPodcastFeedSection
//     {
//         public List<ChannelListItemResponseDTO>? ChannelList { get; set; }
//     }

//     public class PopularShowsTrendingPodcastFeedSection
//     {
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class HotShowsTrendingPodcastFeedSection
//     {
//         public List<ShowListItemResponseDTO>? ShowList { get; set; }
//     }

//     public class NewEpisodesTrendingPodcastFeedSection
//     {
//         public List<PodcastEpisodeSnippetResponseDTO>? EpisodeList { get; set; }
//     }

//     public class PopularEpisodesTrendingPodcastFeedSection
//     {
//         public List<PodcastEpisodeSnippetResponseDTO>? EpisodeList { get; set; }
//     }
// }


// namespace PodcastService.BusinessLogic.DTOs.Episode
// {
//     public class PodcastEpisodeSnippetResponseDTO
//     {
//         public Guid Id { get; set; }
//         public required string Name { get; set; }
//         public string? MainImageFileKey { get; set; }
//     }
// }

// namespace PodcastService.BusinessLogic.DTOs.Account
// {
//     public class AccountSnippetResponseDTO
//     {
//         public int Id { get; set; }
//         public required string FullName { get; set; }
//         public required string Email { get; set; }
//         public string? MainImageFileKey { get; set; }
//     }
// }

// using Microsoft.AspNetCore.Http;
// using PodcastService.BusinessLogic.DTOs.Account;
// using PodcastService.BusinessLogic.DTOs.Category;
// using PodcastService.BusinessLogic.DTOs.Channel;
// using PodcastService.BusinessLogic.DTOs.Channel.ListItems;
// using PodcastService.BusinessLogic.DTOs.Hashtag;

// namespace PodcastService.BusinessLogic.DTOs.Show.ListItems
// {
//     public class ShowListItemResponseDTO
//     {
//         public Guid Id { get; set; }
//         public string Name { get; set; } = null!;
//         public string Description { get; set; } = null!;
//         public string Language { get; set; } = null!;
//         public DateOnly? ReleaseDate { get; set; }
//         public bool? IsReleased { get; set; }
//         public string Copyright { get; set; } = null!;
//         public string? UploadFrequency { get; set; }
//         public int RatingCount { get; set; }
//         public double AverageRating { get; set; }
//         public string? MainImageFileKey { get; set; }
//         public string? TrailerAudioFileKey { get; set; }
//         public int ListenCount { get; set; }
//         public int TotalFollow { get; set; }
//         public int EpisodeCount { get; set; }
//         public AccountSnippetResponseDTO Podcaster { get; set; } = null!;
//         public PodcastCategoryDTO? PodcastCategory { get; set; }
//         public PodcastSubCategoryDTO? PodcastSubCategory { get; set; }
//         public PodcastShowSubscriptionTypeDTO? PodcastShowSubscriptionType { get; set; }
//         public PodcastChannelSnippetResponseDTO? PodcastChannel { get; set; }
//         public List<HashtagDTO>? Hashtags { get; set; }
//         public string? TakenDownReason { get; set; }
//         public DateTime CreatedAt { get; set; }
//         public DateTime UpdatedAt { get; set; }
//         public required PodcastShowStatusDTO CurrentStatus { get; set; } = null!;
//     }
// }

// using Microsoft.AspNetCore.Http;
// using PodcastService.BusinessLogic.DTOs.Account;
// using PodcastService.BusinessLogic.DTOs.Category;
// using PodcastService.BusinessLogic.DTOs.Hashtag;

// namespace PodcastService.BusinessLogic.DTOs.Channel.ListItems
// {
//     public class ChannelListItemResponseDTO
//     {
//         public Guid Id { get; set; }

//         public string Name { get; set; } = null!;

//         public string Description { get; set; } = null!;

//         public string? BackgroundImageFileKey { get; set; }

//         public string? MainImageFileKey { get; set; }

//         public int TotalFavorite { get; set; }

//         public int ListenCount { get; set; }
//         public int ShowCount { get; set; }

//         public AccountSnippetResponseDTO Podcaster { get; set; } = null!;

//         public PodcastCategoryDTO? PodcastCategory { get; set; }

//         public PodcastSubCategoryDTO? PodcastSubCategory { get; set; }

//         public List<HashtagDTO>? Hashtags { get; set; }
//         public DateTime CreatedAt { get; set; }
//         public DateTime UpdatedAt { get; set; }

//         public required PodcastChannelStatusDTO CurrentStatus { get; set; } = null!;

//     }
// }
// using Microsoft.AspNetCore.Http;

// namespace PodcastService.BusinessLogic.DTOs.Category.ListItems
// {
//     public class PodcastSubCategoryListItemResponseDTO : PodcastSubCategoryDTO
//     {
//         public PodcastCategoryDTO PodcastCategory { get; set; } = null!;
//     }
// }

// using PodcastService.DataAccess.Repositories.interfaces;
// using Microsoft.EntityFrameworkCore;
// using PodcastService.DataAccess.Data;
// using System.Linq.Expressions;
// using Newtonsoft.Json.Linq;

// namespace PodcastService.BusinessLogic.Models.CrossService
// {
//     public class BatchQueryRequest
//     {
//         public List<BatchQueryItem> Queries { get; set; } = new();
//         public BatchQueryOptions? Options { get; set; }
//     }

//     public class BatchQueryItem
//     {
//         public string Key { get; set; } = string.Empty;
//         public string EntityType { get; set; } = string.Empty;
//         public string QueryType { get; set; } = string.Empty;
//         public JObject Parameters { get; set; } = new JObject();
//         public string[] Fields { get; set; } = Array.Empty<string>();
//     }

//     public class BatchQueryOptions
//     {
//         public bool UseParallelExecution { get; set; } = true;
//         public int TimeoutMs { get; set; } = 30000;
//         public bool ContinueOnError { get; set; } = true;
//     }
// }


// using PodcastService.DataAccess.Repositories.interfaces;
// using Microsoft.EntityFrameworkCore;
// using PodcastService.DataAccess.Data;
// using System.Linq.Expressions;
// using Newtonsoft.Json.Linq;

// namespace PodcastService.BusinessLogic.Models.CrossService
// {
//     public class BatchQueryResult
//     {
//         public JObject Results { get; set; } = new JObject();
//         public long ExecutionTimeMs { get; set; }
//         public List<string> Errors { get; set; } = new();
//         public bool IsSuccess => !Errors.Any();
//     }
// }

// using PodcastService.DataAccess.Repositories.interfaces;
// using Microsoft.EntityFrameworkCore;
// using PodcastService.DataAccess.Data;
// using System.Linq.Expressions;

// namespace PodcastService.BusinessLogic.Models.CrossService
// {
//     public class CrossServiceQueryOptions<T, TResult> where T : class
//     {
//         public Expression<Func<T, object>>[] IncludeProperties { get; set; } = Array.Empty<Expression<Func<T, object>>>();
//         public string[] SelectFields { get; set; } = Array.Empty<string>();
//         public List<ExternalQueryDefinition> ExternalQueries { get; set; } = new();
//         public Expression<Func<T, Dictionary<string, object>, TResult>> ResultMapper { get; set; } = null!;
//         public TimeSpan? CacheDuration { get; set; }
//         public bool UseParallelExecution { get; set; } = true;
//     }

//     public class ExternalQueryDefinition
//     {
//         public string Key { get; set; } = string.Empty;
//         public string ServiceName { get; set; } = string.Empty;
//         public string EntityType { get; set; } = string.Empty;
//         public string QueryType { get; set; } = string.Empty;
//         public Dictionary<string, object> Parameters { get; set; } = new();
//         public string[] Fields { get; set; } = Array.Empty<string>();
//         public Expression<Func<object, Dictionary<string, object>>>? ParameterMapper { get; set; }
//     }
// }

// using PodcastService.DataAccess.Repositories.interfaces;
// using Microsoft.EntityFrameworkCore;
// using PodcastService.DataAccess.Data;
// using System.Linq.Expressions;

// namespace PodcastService.BusinessLogic.Models.CrossService
// {
//     public class PagedResult<T>
//     {
//         public List<T> Items { get; set; } = new();
//         public int TotalCount { get; set; }
//         public int PageNumber { get; set; }
//         public int PageSize { get; set; }
//         public int TotalPages => (int)Math.Ceiling((double)TotalCount / PageSize);
//         public bool HasNextPage => PageNumber < TotalPages;
//         public bool HasPreviousPage => PageNumber > 1;
//     }
// }

// using Microsoft.EntityFrameworkCore;
// using Microsoft.Extensions.Logging;
// using Newtonsoft.Json;
// using Newtonsoft.Json.Linq;
// using PodcastService.Common.AppConfigurations.App.interfaces;
// using PodcastService.Common.AppConfigurations.FilePath.interfaces;
// using PodcastService.DataAccess.Data;
// using PodcastService.DataAccess.UOW;
// using PodcastService.Infrastructure.Configurations.Payos.interfaces;
// using PodcastService.BusinessLogic.Helpers.AuthHelpers;
// using PodcastService.BusinessLogic.Helpers.FileHelpers;
// using PodcastService.DataAccess.Repositories.interfaces;
// using PodcastService.DataAccess.Entities.SqlServer;
// using PodcastService.BusinessLogic.Services.CrossServiceServices.QueryServices;
// using PodcastService.Infrastructure.Services.Redis;
// using PodcastService.Common.AppConfigurations.BusinessSetting.interfaces;
// using PodcastService.BusinessLogic.DTOs.Cache.QueryMetric;
// using PodcastService.BusinessLogic.Helpers.DateHelpers;
// using PodcastService.BusinessLogic.Enums.Podcast;
// using System.Linq.Expressions;
// using PodcastService.BusinessLogic.Models.CrossService;
// using PodcastService.BusinessLogic.DTOs.Account;

// namespace PodcastService.BusinessLogic.Services.DbServices.CachingServices
// {
//     public class QueryMetricCachingService
//     {
//         // LOGGER
//         private readonly ILogger<QueryMetricCachingService> _logger;

//         // CONFIG
//         public readonly IAppConfig _appConfig;
//         private readonly IFilePathConfig _filePathConfig;
//         private readonly IPayosConfig _payosConfig;
//         private readonly IBackgroundJobsConfig _jobsConfig;

//         // DB CONTEXT
//         private readonly AppDbContext _appDbContext;

//         // HELPERS
//         private readonly BcryptHelper _bcryptHelper;
//         private readonly JwtHelper _jwtHelper;
//         private readonly FileIOHelper _fileIOHelper;
//         private readonly DateHelper _dateHelper;

//         // UNIT OF WORK
//         private readonly IUnitOfWork _unitOfWork;

//         // REPOSITORIES
//         private readonly IGenericRepository<PodcastChannel> _podcastChannelGenericRepository;
//         private readonly IGenericRepository<PodcastChannelStatusTracking> _podcastChannelStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastChannelHashtag> _podcastChannelHashtagGenericRepository;
//         private readonly IGenericRepository<Hashtag> _hashtagGenericRepository;
//         private readonly IGenericRepository<PodcastShow> _podcastShowGenericRepository;
//         private readonly IGenericRepository<PodcastShowStatusTracking> _podcastShowStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastShowHashtag> _podcastShowHashtagGenericRepository;
//         private readonly IGenericRepository<PodcastEpisode> _podcastEpisodeGenericRepository;
//         private readonly IGenericRepository<PodcastShowReview> _podcastShowReviewGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeStatusTracking> _podcastEpisodeStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeHashtag> _podcastEpisodeHashtagGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeLicense> _podcastEpisodeLicenseGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeLicenseType> _podcastEpisodeLicenseTypeGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishReviewSession> _podcastEpisodePublishReviewSessionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishDuplicateDetection> _podcastEpisodePublishDuplicateDetectionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeIllegalContentTypeMarking> _podcastEpisodeIllegalContentTypeMarkingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishReviewSessionStatusTracking> _podcastEpisodePublishReviewSessionStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeListenSession> _podcastEpisodeListenSessionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeListenSessionHlsEnckeyRequestToken> _podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository;

//         private readonly HttpServiceQueryClient _httpServiceQueryClient;

//         private readonly RedisSharedCacheService _redisSharedCacheService;


//         public QueryMetricCachingService(
//             ILogger<QueryMetricCachingService> logger,
//             AppDbContext appDbContext,
//             BcryptHelper bcryptHelper,
//             DateHelper dateHelper,
//             JwtHelper jwtHelper,
//             IUnitOfWork unitOfWork,


//             FileIOHelper fileIOHelper,
//             IFilePathConfig filePathConfig,
//             IAppConfig appConfig,
//             IPayosConfig payosConfig,
//             IBackgroundJobsConfig jobsConfig,

//             HttpServiceQueryClient httpServiceQueryClient,

//             IGenericRepository<PodcastChannel> podcastChannelGenericRepository,
//             IGenericRepository<PodcastChannelStatusTracking> podcastChannelStatusTrackingGenericRepository,
//             IGenericRepository<PodcastChannelHashtag> podcastChannelHashtagGenericRepository,
//             IGenericRepository<Hashtag> hashtagGenericRepository,
//             IGenericRepository<PodcastShow> podcastShowGenericRepository,
//             IGenericRepository<PodcastShowStatusTracking> podcastShowStatusTrackingGenericRepository,
//             IGenericRepository<PodcastShowHashtag> podcastShowHashtagGenericRepository,
//             IGenericRepository<PodcastEpisode> podcastEpisodeGenericRepository,
//             IGenericRepository<PodcastShowReview> podcastShowReviewGenericRepository,
//             IGenericRepository<PodcastEpisodeStatusTracking> podcastEpisodeStatusTrackingGenericRepository,
//             IGenericRepository<PodcastEpisodeHashtag> podcastEpisodeHashtagGenericRepository,
//             IGenericRepository<PodcastEpisodeLicense> podcastEpisodeLicenseGenericRepository,
//             IGenericRepository<PodcastEpisodeLicenseType> podcastEpisodeLicenseTypeGenericRepository,
//             IGenericRepository<PodcastEpisodePublishReviewSession> podcastEpisodePublishReviewSessionGenericRepository,
//             IGenericRepository<PodcastEpisodePublishDuplicateDetection> podcastEpisodePublishDuplicateDetectionGenericRepository,
//             IGenericRepository<PodcastEpisodeIllegalContentTypeMarking> podcastEpisodeIllegalContentTypeMarkingGenericRepository,
//             IGenericRepository<PodcastEpisodePublishReviewSessionStatusTracking> podcastEpisodePublishReviewSessionStatusTrackingGenericRepository,
//             IGenericRepository<PodcastEpisodeListenSession> podcastEpisodeListenSessionGenericRepository,
//             IGenericRepository<PodcastEpisodeListenSessionHlsEnckeyRequestToken> podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository,


//             RedisSharedCacheService redisSharedCacheService
//             )
//         {
//             _logger = logger;
//             _appDbContext = appDbContext;
//             _bcryptHelper = bcryptHelper;
//             _dateHelper = dateHelper;
//             _jwtHelper = jwtHelper;
//             _unitOfWork = unitOfWork;


//             _fileIOHelper = fileIOHelper;
//             _filePathConfig = filePathConfig;
//             _appConfig = appConfig;
//             _payosConfig = payosConfig;
//             _jobsConfig = jobsConfig;

//             _httpServiceQueryClient = httpServiceQueryClient;

//             _podcastChannelGenericRepository = podcastChannelGenericRepository;
//             _podcastChannelStatusTrackingGenericRepository = podcastChannelStatusTrackingGenericRepository;
//             _podcastChannelHashtagGenericRepository = podcastChannelHashtagGenericRepository;
//             _hashtagGenericRepository = hashtagGenericRepository;
//             _podcastShowGenericRepository = podcastShowGenericRepository;
//             _podcastShowStatusTrackingGenericRepository = podcastShowStatusTrackingGenericRepository;
//             _podcastShowHashtagGenericRepository = podcastShowHashtagGenericRepository;
//             _podcastEpisodeGenericRepository = podcastEpisodeGenericRepository;
//             _podcastShowReviewGenericRepository = podcastShowReviewGenericRepository;
//             _podcastEpisodeStatusTrackingGenericRepository = podcastEpisodeStatusTrackingGenericRepository;
//             _podcastEpisodeHashtagGenericRepository = podcastEpisodeHashtagGenericRepository;
//             _podcastEpisodeLicenseGenericRepository = podcastEpisodeLicenseGenericRepository;
//             _podcastEpisodeLicenseTypeGenericRepository = podcastEpisodeLicenseTypeGenericRepository;
//             _podcastEpisodePublishReviewSessionGenericRepository = podcastEpisodePublishReviewSessionGenericRepository;
//             _podcastEpisodePublishDuplicateDetectionGenericRepository = podcastEpisodePublishDuplicateDetectionGenericRepository;
//             _podcastEpisodeIllegalContentTypeMarkingGenericRepository = podcastEpisodeIllegalContentTypeMarkingGenericRepository;
//             _podcastEpisodePublishReviewSessionStatusTrackingGenericRepository = podcastEpisodePublishReviewSessionStatusTrackingGenericRepository;
//             _podcastEpisodeListenSessionGenericRepository = podcastEpisodeListenSessionGenericRepository;
//             _podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository = podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository;

//             _redisSharedCacheService = redisSharedCacheService;
//         }


//         private async Task<(List<TEntity> entities, int daysBack, int distinctCount)> QueryIncrementalWithMinDistinctAsync<TEntity, TKey>(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack,
//             Func<DateTime, DateTime, Expression<Func<TEntity, bool>>> predicateFactory,
//             Func<IQueryable<TEntity>, IQueryable<TEntity>> includeFunc,
//             Func<TEntity, TKey> distinctKeySelector
//         ) where TEntity : class
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();
//             int currentDaysBack = 0;

//             List<TEntity> accumulatedEntities = new List<TEntity>();
//             int distinctCount = 0;

//             Console.WriteLine($"[QueryIncremental] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Lấy repository tương ứng với TEntity
//             var repository = GetRepositoryForEntity<TEntity>();

//             while (currentDaysBack < maxDaysBack)
//             {
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[QueryIncremental] Querying batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Tạo predicate cho batch hiện tại
//                 var predicate = predicateFactory(batchStartDate, batchEndDate);

//                 // Query batch
//                 var batchEntities = await repository.FindAll(
//                     predicate: predicate,
//                     includeFunc: includeFunc
//                 ).ToListAsync();

//                 Console.WriteLine($"[QueryIncremental] Batch returned {batchEntities.Count} entities");

//                 // Nếu batch rỗng, dừng vì không còn data
//                 if (batchEntities.Count == 0)
//                 {
//                     Console.WriteLine($"[QueryIncremental] No more data found, stopping at {currentDaysBack + daysBatchSize} days back");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedEntities.AddRange(batchEntities);

//                 // Tính distinct count
//                 distinctCount = accumulatedEntities
//                     .Select(distinctKeySelector)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[QueryIncremental] Total accumulated: {accumulatedEntities.Count}, Distinct: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[QueryIncremental] Condition met: {distinctCount} distinct entities in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[QueryIncremental] Completed - Total entities: {accumulatedEntities.Count}, Days back: {currentDaysBack}, Distinct: {distinctCount}");

//             return (accumulatedEntities, currentDaysBack, distinctCount);
//         }

//         /// <summary>
//         /// Helper method để lấy repository phù hợp với entity type
//         /// </summary>
//         private IGenericRepository<TEntity> GetRepositoryForEntity<TEntity>() where TEntity : class
//         {
//             var entityType = typeof(TEntity);

//             if (entityType == typeof(PodcastEpisodeListenSession))
//                 return (IGenericRepository<TEntity>)_podcastEpisodeListenSessionGenericRepository;

//             // if (entityType == typeof(PodcastShowFollow))
//             //     return (IGenericRepository<TEntity>)_podcastShowFollowGenericRepository; // Cần thêm repository này vào constructor

//             // if (entityType == typeof(PodcastChannelFavorite))
//             //     return (IGenericRepository<TEntity>)_podcastChannelFavoriteGenericRepository; // Cần thêm repository này vào constructor

//             throw new NotSupportedException($"Repository for entity type {entityType.Name} is not registered");
//         }

//         private async Task<(List<AccountFollowedPodcastShowDTO> follows, int daysBack, int distinctCount)> GetAccountNewFollowedPodcastShowAsync(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack
//         )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFollowedPodcastShow] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ follows từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFollowedPodcastShows",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcastShow",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["accountFollowedPodcastShows"].ToObject<List<AccountFollowedPodcastShowDTO>>();

//             Console.WriteLine($"[GetAccountNewFollowedPodcastShow] Total follows from UserService: {allFollows.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFollowedPodcastShowDTO> accumulatedFollows = new List<AccountFollowedPodcastShowDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);


//                 // Filter follows trong batch hiện tại
//                 var batchFollows = allFollows
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();


//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFollows.Count == 0)
//                 {
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFollows.AddRange(batchFollows);

//                 // Tính distinct show count
//                 distinctCount = accumulatedFollows
//                     .Select(f => f.PodcastShowId)
//                     .Distinct()
//                     .Count();

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     break;
//                 }
//             }

//             return (accumulatedFollows, currentDaysBack, distinctCount);
//         }

//         private async Task<(List<AccountFavoritedPodcastChannelDTO> favorites, int daysBack, int distinctCount)> GetAccountNewFavoritedPodcastChannelAsync(
//     int daysBatchSize,
//     int minDistinctEntityCount,
//     int minDaysBack,
//     int maxDaysBack
// )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ favorites từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFavoritedPodcastChannels",
//                 QueryType = "findall",
//                 EntityType = "AccountFavoritedPodcastChannel",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFavorites = result.Results["accountFavoritedPodcastChannels"].ToObject<List<AccountFavoritedPodcastChannelDTO>>();

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Total favorites from UserService: {allFavorites.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFavoritedPodcastChannelDTO> accumulatedFavorites = new List<AccountFavoritedPodcastChannelDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Processing batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Filter favorites trong batch hiện tại
//                 var batchFavorites = allFavorites
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Batch returned {batchFavorites.Count} favorites");

//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFavorites.Count == 0)
//                 {
//                     Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] No more data found in this batch, stopping");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFavorites.AddRange(batchFavorites);

//                 // Tính distinct channel count
//                 distinctCount = accumulatedFavorites
//                     .Select(f => f.PodcastChannelId)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Total accumulated: {accumulatedFavorites.Count}, Distinct channels: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Condition met: {distinctCount} distinct channels in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Completed - Total favorites: {accumulatedFavorites.Count}, Days back: {currentDaysBack}, Distinct channels: {distinctCount}");

//             return (accumulatedFavorites, currentDaysBack, distinctCount);
//         }

//         private async Task<(List<AccountFollowedPodcasterDTO> follows, int daysBack, int distinctCount)> GetAccountNewFollowedPodcasterAsync(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack
//         )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ follows từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFollowedPodcasters",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcaster",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["accountFollowedPodcasters"].ToObject<List<AccountFollowedPodcasterDTO>>();

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Total follows from UserService: {allFollows.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFollowedPodcasterDTO> accumulatedFollows = new List<AccountFollowedPodcasterDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Processing batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Filter follows trong batch hiện tại
//                 var batchFollows = allFollows
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Batch returned {batchFollows.Count} follows");

//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFollows.Count == 0)
//                 {
//                     Console.WriteLine($"[GetAccountNewFollowedPodcaster] No more data found in this batch, stopping");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFollows.AddRange(batchFollows);

//                 // Tính distinct podcaster count
//                 distinctCount = accumulatedFollows
//                     .Select(f => f.PodcasterId)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Total accumulated: {accumulatedFollows.Count}, Distinct podcasters: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[GetAccountNewFollowedPodcaster] Condition met: {distinctCount} distinct podcasters in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Completed - Total follows: {accumulatedFollows.Count}, Days back: {currentDaysBack}, Distinct podcasters: {distinctCount}");

//             return (accumulatedFollows, currentDaysBack, distinctCount);
//         }


//         /////////////////////////////////////////////////////////////
//         public async Task UpdatePodcasterAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // Logic to update podcaster all-time max query metric goes here
//                 // truy danh sách podcaster đã được isVerified = true từ UserService
//                 // 1: lấy MaxTotalFollow từ cột totalFollow của tất cả các podcaster trong bảng PodcasterProfile của UserService
//                 // 2: lấy MaxListenCount từ cột ListenCount của tất cả các podcaster trong bảng PodcasterProfile của UserService
//                 // 3: lấy MaxRatingTerm trong đó RatingTerm của mỗi podcaster được tính bằng: RT = AverageRating * log(RatingCount + 1)
//                 // 4: lấy MaxAge từ cột verifiedAt của tất cả các podcaster trong bảng PodcasterProfile của UserService tính từ thời điểm hiện tại
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                 {
//                     new BatchQueryItem
//                     {
//                         Key = "verifiedPodcasterProfiles",
//                         QueryType = "findall",
//                         EntityType = "PodcasterProfile",
//                         Parameters = JObject.FromObject(new
//                         {
//                             IsVerified = true
//                         })
//                     }
//                 }
//                 };
//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var verifiedPodcasterProfiles = result.Results["verifiedPodcasterProfiles"].ToObject<List<PodcasterProfileDTO>>();

//                 var podcasterAllTimeMaxQueryMetric = new PodcasterAllTimeMaxQueryMetric
//                 {
//                     MaxTotalFollow = verifiedPodcasterProfiles
//                         .Select(g => g.TotalFollow)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxListenCount = verifiedPodcasterProfiles
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),
//                     MaxAge = verifiedPodcasterProfiles
//                         .Select(pp => pp.VerifiedAt.HasValue
//                             ? (int)(_dateHelper.GetNowByAppTimeZone() - pp.VerifiedAt.Value).TotalDays
//                             : 0)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxRatingTerm = verifiedPodcasterProfiles
//                         .Select(pp => pp.AverageRating * Math.Log(pp.RatingCount + 1))
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, podcasterAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdatePodcasterAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }
//         public async Task UpdatePodcasterTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // truy danh sách podcaster đã được isVerified = true từ UserService
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity >= 5 podcaster) từ bảng PodcastEpisodeListenSession liên kết với PodcasterProfile của UserService
//                 // 2: lấy MaxNewFollow 7 ngày tối thiểu về trước (entity >= 5 podcaster) từ bảng AccountFollowedPodcaster của UserService
//                 // 3: lấy MaxGrowth 7 ngày tối thiểu về trước (entity >= 5 podcaster) trong đó Growth của mỗi podcaster được tính bằng: G = NewListenSessionCount + NewFollowCount
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                 {
//                     new BatchQueryItem
//                     {
//                         Key = "verifiedPodcasterProfiles",
//                         QueryType = "findall",
//                         EntityType = "PodcasterProfile",
//                         Parameters = JObject.FromObject(new
//                         {
//                             IsVerified = true
//                         })
//                     }
//                 }
//                 };
//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var verifiedPodcasterProfiles = result.Results["verifiedPodcasterProfiles"].ToObject<List<PodcasterProfileDTO>>();
//                 var verifiedPodcasterIds = verifiedPodcasterProfiles
//                     .Select(pp => pp.AccountId)
//                     .ToHashSet();

//                 var (newFollows, followDaysBack, followDistinctCount) = await GetAccountNewFollowedPodcasterAsync(
//                     daysBatchSize: 7,
//                     minDistinctEntityCount: 5,
//                     minDaysBack: 7,
//                     maxDaysBack: 365
//                 );

//                 newFollows = newFollows
//                     .Where(f => verifiedPodcasterIds.Contains(f.PodcasterId))
//                     .ToList();


//                 var (listenSessions, listenDaysBack, distinctShowCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc: q => q.Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShow.PodcasterId
//                     );

//                 listenSessions = listenSessions
//                     .Where(ls => verifiedPodcasterIds.Contains(ls.PodcastEpisode.PodcastShow.PodcasterId))
//                     .ToList();

//                 var podcasterIdsInListenSessions = listenSessions
//                     .Select(ls => ls.PodcastEpisode.PodcastShow.PodcasterId)
//                     .Distinct();

//                 var podcasterIdsInFollows = newFollows
//                     .Select(nf => nf.PodcasterId)
//                     .Distinct();

//                 var allTemporalPodcasterIds = podcasterIdsInListenSessions
//                     .Union(podcasterIdsInFollows)
//                     .Distinct()
//                     .ToList();

//                 var podcasterTemporal7dMaxQueryMetric = new PodcasterTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new
//                         {
//                             PodcasterId = g.Key,
//                             NewListenSessionCount = g.Count()
//                         })
//                         .Select(x => x.NewListenSessionCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxNewFollow = newFollows
//                         .GroupBy(afps => afps.PodcasterId)
//                         .Select(g => new
//                         {
//                             PodcasterId = g.Key,
//                             NewFollowCount = g.Count()
//                         })
//                         .Select(x => x.NewFollowCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxGrowth = allTemporalPodcasterIds
//                         .Select(podcasterId =>
//                         {
//                             var newListenSessionCount = listenSessions
//                                 .Count(ls => ls.PodcastEpisode.PodcastShow.PodcasterId == podcasterId);
//                             var newFollowCount = newFollows
//                                 .Count(nf => nf.PodcasterId == podcasterId);
//                             return newListenSessionCount + newFollowCount;
//                         })
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, podcasterTemporal7dMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));

//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdatePodcasterTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }

//         public async Task UpdateShowAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // 1: lấy MaxTotalFollow từ cột totalFollow của tất cả các show (chưa bị xoá / Removed) trong bảng PodcastShow
//                 // 2: lấy MaxListenCount từ cột ListenCount của tất cả các show (chưa bị xoá / Removed) trong bảng PodcastShow
//                 // 3: lấy MaxRatingTerm trong đó RatingTerm của mỗi show được tính bằng: RT = AverageRating * log(RatingCount + 1)
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var allTimeShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps => ps.DeletedAt == null &&
//                     // trạng thái cuối cùng không phải là Removed
//                     ps.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed
//                     ,
//                     includeFunc: null
//                 ).ToListAsync();

//                 var showAllTimeMaxQueryMetric = new ShowAllTimeMaxQueryMetric
//                 {
//                     MaxTotalFollow = allTimeShows
//                         .Select(g => g.TotalFollow)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxListenCount = allTimeShows
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxRatingTerm = allTimeShows
//                         .Select(ps => ps.AverageRating * Math.Log(ps.RatingCount + 1))
//                         .DefaultIfEmpty(0)
//                         .Max(),


//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, showAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateShowAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }

//         public async Task UpdateChannelAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update channel all-time max query metric goes here
//                 // 1: lấy MaxListenCount từ cột ListenCount của tất cả các channel (chưa bị xoá) trong bảng PodcastChannel
//                 // 2: lấy MaxTotalFavorite từ cột TotalFavorite của tất cả các channel (chưa bị xoá) trong bảng PodcastChannel
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;


//                 var allTimeChannels = await _podcastChannelGenericRepository.FindAll(
//                     predicate: pc => pc.DeletedAt == null,
//                     includeFunc: null
//                 ).ToListAsync();
//                 var channelAllTimeMaxQueryMetric = new ChannelAllTimeMaxQueryMetric
//                 {
//                     MaxListenCount = allTimeChannels
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),
//                     MaxTotalFavorite = allTimeChannels
//                         .Select(g => g.TotalFavorite)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, channelAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateChannelAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateShowTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // NGUYÊN TẮT TRONG TEMPORAL: 7 NGÀY LÀ TỐI THIẾU CÓ THỂ HƠN 7 NGÀY MIỄN SAO ĐẢM BẢO MIN RECORD ENTITY = 5 SHOW / CHANNEL / PODCASTER
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update show temporal 7-day max query metric goes here
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng PodcastShowListenSession
//                 // 2: lấy MaxNewFollow 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng AccountFollowedPodcastShow
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;


//                 // ============ Query MaxNewListenSession ============
//                 var (listenSessions, listenDaysBack, distinctShowCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, Guid>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault().PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc: q => q.Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShowId
//                     );

//                 // Tính MaxNewListenSession
//                 int maxNewListenSession = 0;
//                 if (listenSessions.Count > 0)
//                 {
//                     var listenSessionByShow = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShowId)
//                         .Select(g => new
//                         {
//                             PodcastShowId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewListenSession = listenSessionByShow
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Query MaxNewFollow ============
//                 var (follows, followDaysBack, distinctShowCountForFollow) =
//                     await GetAccountNewFollowedPodcastShowAsync(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365
//                     );

//                 int maxNewFollow = 0;
//                 if (follows.Count > 0)
//                 {
//                     var followsByShow = follows
//                         .GroupBy(f => f.PodcastShowId)
//                         .Select(g => new { PodcastShowId = g.Key, Count = g.Count() })
//                         .ToList();

//                     maxNewFollow = followsByShow.Select(x => x.Count).Max();
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, followDaysBack);

//                 var metric = new ShowTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = maxNewListenSession,
//                     MaxNewFollow = maxNewFollow,
//                     LastUpdated = now
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateShowTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateChannelTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // NGUYÊN TẮT TRONG TEMPORAL: 7 NGÀY LÀ TỐI THIẾU CÓ THỂ HƠN 7 NGÀY MIỄN SAO ĐẢM BẢO MIN RECORD ENTITY = 5 SHOW / CHANNEL / PODCASTER
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update channel temporal 7-day max query metric goes here
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng PodcastShowListenSession
//                 // 2: lấy MaxNewFavorite 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng AccountFavoritedPodcastChannel
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job
//                 var cacheKey = _jobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Query MaxNewListenSession ============
//                 // Query listen sessions từ episodes thuộc channels
//                 var (listenSessions, listenDaysBack, distinctChannelCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, Guid?>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault().PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null,
//                         includeFunc: q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastChannel),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShow.PodcastChannelId
//                     );

//                 // Tính MaxNewListenSession
//                 int maxNewListenSession = 0;
//                 if (listenSessions.Count > 0)
//                 {
//                     var listenSessionByChannel = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcastChannelId)
//                         .Select(g => new
//                         {
//                             PodcastChannelId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewListenSession = listenSessionByChannel
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Query MaxNewFavorite ============
//                 var (favorites, favoriteDaysBack, distinctChannelCountForFavorite) =
//                     await GetAccountNewFavoritedPodcastChannelAsync(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365
//                     );

//                 int maxNewFavorite = 0;
//                 if (favorites.Count > 0)
//                 {
//                     var favoritesByChannel = favorites
//                         .GroupBy(f => f.PodcastChannelId)
//                         .Select(g => new
//                         {
//                             PodcastChannelId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewFavorite = favoritesByChannel
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, favoriteDaysBack);

//                 var metric = new ChannelTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = maxNewListenSession,
//                     MaxNewFavorite = maxNewFavorite,
//                     LastUpdated = now
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateChannelTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateSystemPreferencesTemporal30dQueryMetric()
//         {
//             try
//             {
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update System Preferences temporal 30-day goes here
//                 // 1: lấy ListenedPodcastCategories[] 30 ngày tối thiểu về trước (entity phải 4 categories min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 4 categories) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcastCategoriy có categoryId, listenCount, PodcastSubCategories (có subcategoryId, listenCount)
//                 // 2: lấy ListenedPodcaster[] 30 ngày tối thiểu về trước (entity phải 2 podcasters min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 2 podcasters) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcaster có podcasterId, listenCount
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Query ListenedPodcastCategory[] ============
//                 var (listenSessions, listenDaysBack, distinctCategoryCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int?>(
//                         daysBatchSize: 15,
//                         minDistinctEntityCount: 4,
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc:
//                         q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         //     .ThenInclude(ps => ps.PodcastShowHashtags)
//                         //     .ThenInclude(psh => psh.Hashtag),
//                         distinctKeySelector: pes =>
//                             pes.PodcastCategoryId
//                     );

//                 List<SystemListenedPodcastCategory> ListenedPodcastCategories = new List<SystemListenedPodcastCategory>();
//                 if (listenSessions.Count > 0)
//                 {
//                     var categoryListenCounts = listenSessions
//                         .Where(pes => pes.PodcastCategoryId.HasValue)
//                         .GroupBy(pes => pes.PodcastCategoryId.Value)
//                         .Select(g => new SystemListenedPodcastCategory
//                         {
//                             PodcastCategoryId = g.Key,
//                             ListenCount = g.Count(),
//                             PodcastSubCategories = g
//                                 .Where(pes => pes.PodcastSubCategoryId.HasValue)
//                                 .GroupBy(pes => pes.PodcastSubCategoryId.Value)
//                                 .Select(sg => new SystemListenedPodcastSubCategory
//                                 {
//                                     PodcastSubCategoryId = sg.Key,
//                                     ListenCount = sg.Count()
//                                 })
//                                 .OrderByDescending(x => x.ListenCount)
//                                 .ToList()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     ListenedPodcastCategories = categoryListenCounts;
//                 }

//                 // ============ Query ListenedPodcaster[] ============
//                 var (listenSessionsForPodcaster, listenDaysBackForPodcaster, distinctPodcasterCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 15,
//                         minDistinctEntityCount: 2,
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc:
//                         q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes =>
//                             pes.PodcastEpisode.PodcastShow.PodcasterId
//                     );

//                 List<SystemListenedPodcaster> ListenedPodcasters = new List<SystemListenedPodcaster>();
//                 if (listenSessionsForPodcaster.Count > 0)
//                 {
//                     var podcasterListenCounts = listenSessionsForPodcaster
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new SystemListenedPodcaster
//                         {
//                             PodcasterId = g.Key,
//                             ListenCount = g.Count()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     ListenedPodcasters = podcasterListenCounts;
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, listenDaysBackForPodcaster);
//                 var metric = new SystemPreferencesTemporal30dQueryMetric
//                 {
//                     ListenedPodcastCategories = ListenedPodcastCategories,
//                     ListenedPodcasters = ListenedPodcasters,
//                     LastUpdated = now
//                 };
//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateSystemPreferencesTemporal30dQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateUserPreferencesTemporal30dQueryMetric()
//         {
//             try
//             {
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update User Preferences temporal 30-day goes here
//                 // group by AccountId và đưa vào field UserId trong DTO
//                 // 1: lấy ListenedPodcastCategories[] 30 ngày tối thiểu về trước (entity phải 4 categories min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 4 categories) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcastCategoriy có categoryId, listenCount, PodcastSubCategories (có subcategoryId, listenCount)
//                 // 2: lấy ListenedPodcaster[] 30 ngày tối thiểu về trước (entity phải 2 podcasters min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 2 podcasters) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcaster có podcasterId, listenCount
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.UserPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.UserPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Bước 1: Query để lấy distinct users (không giới hạn số lượng user) ============
//                 var (allUserListenSessions, _, distinctUserCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 30,
//                         minDistinctEntityCount: 1, // Lấy tất cả users, không giới hạn
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null ||
//                              (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                               pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null)),
//                         includeFunc: q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.AccountId
//                     );

//                 // Extract distinct user IDs
//                 var distinctUserIds = allUserListenSessions
//                     .Select(pes => pes.AccountId)
//                     .Distinct()
//                     .ToList();

//                 Console.WriteLine($"[UserPreferencesTemporal30d] Found {distinctUserIds.Count} distinct users");

//                 // ============ Bước 2: Xử lý từng user ============
//                 var now = _dateHelper.GetNowByAppTimeZone();

//                 foreach (var userId in distinctUserIds)
//                 {
//                     // Filter sessions của user này
//                     var userSessions = allUserListenSessions
//                         .Where(pes => pes.AccountId == userId)
//                         .ToList();

//                     // ============ Incremental filtering cho Categories (min 4) ============
//                     int daysBatchSize = 15;
//                     int currentDaysBackForCategory = 0;
//                     int minDaysBack = 30;
//                     int maxDaysBack = 365;

//                     List<PodcastEpisodeListenSession> accumulatedCategorySessions = new List<PodcastEpisodeListenSession>();
//                     int distinctCategoryCount = 0;

//                     while (currentDaysBackForCategory < maxDaysBack)
//                     {
//                         var batchStartDate = now.AddDays(-(currentDaysBackForCategory + daysBatchSize));
//                         var batchEndDate = now.AddDays(-currentDaysBackForCategory);

//                         var batchSessions = userSessions
//                             .Where(pes => pes.CreatedAt >= batchStartDate && pes.CreatedAt < batchEndDate)
//                             .ToList();

//                         if (batchSessions.Count == 0)
//                             break;

//                         accumulatedCategorySessions.AddRange(batchSessions);

//                         distinctCategoryCount = accumulatedCategorySessions
//                             .Where(pes => pes.PodcastCategoryId.HasValue)
//                             .Select(pes => pes.PodcastCategoryId.Value)
//                             .Distinct()
//                             .Count();

//                         currentDaysBackForCategory += daysBatchSize;

//                         if (distinctCategoryCount >= 4 && currentDaysBackForCategory >= minDaysBack)
//                             break;
//                     }

//                     // Tính ListenedPodcastCategories
//                     var listenedCategories = accumulatedCategorySessions
//                         .Where(pes => pes.PodcastCategoryId.HasValue)
//                         .GroupBy(pes => pes.PodcastCategoryId.Value)
//                         .Select(g => new UserListenedPodcastCategory
//                         {
//                             PodcastCategoryId = g.Key,
//                             ListenCount = g.Count(),
//                             PodcastSubCategories = g
//                                 .Where(pes => pes.PodcastSubCategoryId.HasValue)
//                                 .GroupBy(pes => pes.PodcastSubCategoryId.Value)
//                                 .Select(sg => new UserListenedPodcastSubCategory
//                                 {
//                                     PodcastSubCategoryId = sg.Key,
//                                     ListenCount = sg.Count()
//                                 })
//                                 .OrderByDescending(x => x.ListenCount)
//                                 .ToList()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     // ============ Incremental filtering cho Podcasters (min 2) ============
//                     int currentDaysBackForPodcaster = 0;
//                     List<PodcastEpisodeListenSession> accumulatedPodcasterSessions = new List<PodcastEpisodeListenSession>();
//                     int distinctPodcasterCount = 0;

//                     while (currentDaysBackForPodcaster < maxDaysBack)
//                     {
//                         var batchStartDate = now.AddDays(-(currentDaysBackForPodcaster + daysBatchSize));
//                         var batchEndDate = now.AddDays(-currentDaysBackForPodcaster);

//                         var batchSessions = userSessions
//                             .Where(pes => pes.CreatedAt >= batchStartDate && pes.CreatedAt < batchEndDate)
//                             .ToList();

//                         if (batchSessions.Count == 0)
//                             break;

//                         accumulatedPodcasterSessions.AddRange(batchSessions);

//                         distinctPodcasterCount = accumulatedPodcasterSessions
//                             .Select(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                             .Distinct()
//                             .Count();

//                         currentDaysBackForPodcaster += daysBatchSize;

//                         if (distinctPodcasterCount >= 2 && currentDaysBackForPodcaster >= minDaysBack)
//                             break;
//                     }

//                     // Tính ListenedPodcasters
//                     var listenedPodcasters = accumulatedPodcasterSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new UserListenedPodcaster
//                         {
//                             PodcasterId = g.Key,
//                             ListenCount = g.Count()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     // ============ Lưu metric cho user ============
//                     var userMetric = new UserPreferencesTemporal30dQueryMetric
//                     {
//                         UserId = userId,
//                         ListenedPodcastCategories = listenedCategories,
//                         ListenedPodcasters = listenedPodcasters,
//                         LastUpdated = now
//                     };

//                     // Cache riêng cho từng user
//                     await _redisSharedCacheService.KeySetAsync(cacheKey, userMetric, TimeSpan.FromSeconds(cacheTTL ?? 86400));

//                 }

//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateUserPreferencesTemporal30dQueryMetric failed, error: " + ex.Message);
//             }
//         }
//     }
// }


// using Microsoft.Extensions.Logging;
// using PodcastService.Infrastructure.Configurations.Redis.interfaces;
// using StackExchange.Redis;
// using Newtonsoft.Json;

// namespace PodcastService.Infrastructure.Services.Redis
// {
//     public class RedisSharedCacheService
//     {
//         // LOGGER
//         private readonly ILogger<RedisSharedCacheService> _logger;

//         // CONFIG
//         private readonly IRedisDefaultConfig _redisDefaultConfig;
//         private readonly IRedisCacheConfig _redisCacheConfig;
//         private readonly IRedisSessionConfig _redisSessionConfig;
//         private readonly IRedisRateLimitConfig _redisRateLimitConfig;
//         private readonly IRedisMessageQueueConfig _redisMessageQueueConfig;
//         private readonly IRedisLockConfig _redisLockConfig;
//         private readonly IRedisAnalyticsConfig _redisAnalyticsConfig;

//         // REDIS
//         private readonly IDatabase _redisDb;
//         private readonly IConnectionMultiplexer _redis;
//         private readonly IServer _redisServer;
//         private readonly string _redisPrefix;

//         public RedisSharedCacheService(
//             IRedisDefaultConfig redisDefaultConfig,
//             IRedisCacheConfig redisCacheConfig,
//             IRedisSessionConfig redisSessionConfig,
//             IRedisRateLimitConfig redisRateLimitConfig,
//             IRedisMessageQueueConfig redisMessageQueueConfig,
//             IRedisLockConfig redisLockConfig,
//             IRedisAnalyticsConfig redisAnalyticsConfig,
//             IConnectionMultiplexer redis,
//             ILogger<RedisSharedCacheService> logger)
//         {
//             _logger = logger;

//             _redisDefaultConfig = redisDefaultConfig;
//             _redisCacheConfig = redisCacheConfig;
//             _redisSessionConfig = redisSessionConfig;
//             _redisRateLimitConfig = redisRateLimitConfig;
//             _redisMessageQueueConfig = redisMessageQueueConfig;
//             _redisLockConfig = redisLockConfig;
//             _redisAnalyticsConfig = redisAnalyticsConfig;

//             _redis = redis;
//             _redisDb = redis.GetDatabase();
//             _redisPrefix = $"{_redisDefaultConfig.SharedKeyName}:{_redisDefaultConfig.DefaultDatabase}:{_redisCacheConfig.KeyPrefix}";
//             _redisServer = redis.GetServer(_redisDefaultConfig.ConnectionString);
//         }

//         public string GetRedisKey(string key)
//         {
//             return $"{_redisPrefix}:{key}";
//         }

//         public string ValueToString<T>(T value)
//         {
//             if (value is string strValue)
//             {
//                 return strValue;
//             }
//             else if (value is int intValue)
//             {
//                 return intValue.ToString();
//             }
//             else if (value is long longValue)
//             {
//                 return longValue.ToString();
//             }
//             else if (value is double doubleValue)
//             {
//                 return doubleValue.ToString();
//             }
//             else if (value is bool boolValue)
//             {
//                 return boolValue.ToString();
//             }
//             else
//             {
//                 return JsonConvert.SerializeObject(value);
//             }
//         }

//         public TimeSpan GetExpirySeconds(TimeSpan? expiry)
//         {
//             return expiry ?? TimeSpan.FromSeconds(_redisCacheConfig.ExpirySeconds);
//         }

//         // Class để chứa thông tin về key và giá trị trong Redis
//         public class RedisValueInfo
//         {
//             public string Key { get; set; }
//             public string Type { get; set; }
//             public object Value { get; set; }
//             public TimeSpan? Expiry { get; set; }
//             public string Prefix { get; set; }
//             public string OriginalKey { get; set; }
//         }

//         #region Generic Cache Operations
//         // Get tất cả các key-value trong Redis cache với thông tin đầy đủ
//         public async Task<List<RedisValueInfo>> GetAllKeyValuesAsync()
//         {
//             var result = new List<RedisValueInfo>();

//             await foreach (var key in _redisServer.KeysAsync())
//             {
//                 try
//                 {
//                     var keyString = key.ToString();
//                     var type = await _redisDb.KeyTypeAsync(key);
//                     var expiry = await _redisDb.KeyTimeToLiveAsync(key);
//                     object value = null;

//                     // Tách prefix và original key
//                     string prefix = null;
//                     string originalKey = keyString;
//                     if (keyString.Contains(":"))
//                     {
//                         var parts = keyString.Split(':');
//                         prefix = parts[0];
//                         originalKey = string.Join(":", parts.Skip(1));
//                     }

//                     switch (type)
//                     {
//                         case RedisType.String:
//                             value = await _redisDb.StringGetAsync(key);
//                             break;
//                         case RedisType.Hash:
//                             var hashEntries = await _redisDb.HashGetAllAsync(key);
//                             value = hashEntries.ToDictionary(
//                                 entry => entry.Name.ToString(),
//                                 entry => entry.Value.ToString()
//                             );
//                             break;
//                         case RedisType.List:
//                             var listValues = await _redisDb.ListRangeAsync(key);
//                             value = listValues.Select(v => v.ToString()).ToList();
//                             break;
//                         case RedisType.Set:
//                             var setValues = await _redisDb.SetMembersAsync(key);
//                             value = setValues.Select(v => v.ToString()).ToList();
//                             break;
//                         case RedisType.SortedSet:
//                             var sortedSetEntries = await _redisDb.SortedSetRangeByScoreWithScoresAsync(key);
//                             value = sortedSetEntries.ToDictionary(
//                                 entry => entry.Element.ToString(),
//                                 entry => entry.Score
//                             );
//                             break;
//                     }

//                     result.Add(new RedisValueInfo
//                     {
//                         Key = keyString,
//                         Type = type.ToString(),
//                         Value = value,
//                         Expiry = expiry,
//                         Prefix = prefix,
//                         OriginalKey = originalKey
//                     });
//                 }
//                 catch (Exception ex)
//                 {
//                     _logger.LogError(ex, $"Error getting value for key: {key}");
//                 }
//             }

//             return result;
//         }

//         // Set giá trị vào Redis cache với thời gian hết hạn tùy chọn
//         public async Task<bool> KeySetAsync<T>(string key, T value, TimeSpan? expiry = null)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var serializedValue = ValueToString(value);
//                 var expirySeconds = GetExpirySeconds(expiry);
//                 return await _redisDb.StringSetAsync(redisKey, serializedValue, expirySeconds);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error setting cache for key: {key}");
//                 return false;
//             }
//         }

//         // Get giá trị từ Redis cache theo key
//         public async Task<T> KeyGetAsync<T>(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var value = await _redisDb.StringGetAsync(redisKey);
//                 return value.HasValue ? JsonConvert.DeserializeObject<T>(value) : default;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting cache for key: {key}");
//                 return default;
//             }
//         }

//         // Get nhiều giá trị từ Redis cache theo danh sách key
//         public async Task<IDictionary<string, T>> MultipleKeysGetAsync<T>(IEnumerable<string> keys)
//         {
//             try
//             {
//                 var redisKeys = keys.Select(k => (RedisKey)GetRedisKey(k)).ToArray();
//                 var values = await _redisDb.StringGetAsync(redisKeys);
//                 var result = new Dictionary<string, T>();

//                 for (int i = 0; i < keys.Count(); i++)
//                 {
//                     if (values[i].HasValue)
//                     {
//                         result[keys.ElementAt(i)] = JsonConvert.DeserializeObject<T>(values[i]);
//                     }
//                 }

//                 return result;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, "Error getting multiple cache entries");
//                 return new Dictionary<string, T>();
//             }
//         }

//         // Set nhiều cặp key-value vào Redis cache với thời gian hết hạn tùy chọn
//         public async Task<bool> KeyPairsSetAsync<T>(IDictionary<string, T> keyValuePairs, TimeSpan? expiry = null)
//         {
//             try
//             {
//                 var batch = _redisDb.CreateBatch();
//                 var expirySeconds = GetExpirySeconds(expiry);

//                 foreach (var kvp in keyValuePairs)
//                 {
//                     var redisKey = GetRedisKey(kvp.Key);
//                     var serializedValue = ValueToString(kvp.Value);
//                     batch.StringSetAsync(redisKey, serializedValue, expirySeconds);
//                 }

//                 await batch.ExecuteAsync("BATCH");
//                 return true;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, "Error setting multiple cache entries");
//                 return false;
//             }
//         }
//         #endregion

//         #region Cache Management
//         // Delete một key khỏi Redis cache
//         public async Task<bool> KeyDeleteAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 return await _redisDb.KeyDeleteAsync(redisKey);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing cache for key: {key}");
//                 return false;
//             }
//         }

//         // Delete nhiều key khỏi Redis cache
//         public async Task<bool> MultipleKeysDeleteAsync(IEnumerable<string> keys)
//         {
//             try
//             {
//                 var redisKeys = keys.Select(k => (RedisKey)GetRedisKey(k)).ToArray();
//                 return await _redisDb.KeyDeleteAsync(redisKeys) > 0;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, "Error removing multiple cache entries");
//                 return false;
//             }
//         }

//         // Kiểm tra xem một key có tồn tại trong Redis cache không
//         public async Task<bool> IsKeyExistsAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 return await _redisDb.KeyExistsAsync(redisKey);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error checking cache existence for key: {key}");
//                 return false;
//             }
//         }

//         // Set thời gian hết hạn cho một key trong Redis cache
//         public async Task<bool> KeyExpirySetAsync(string key, TimeSpan? expiry)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var expirySeconds = GetExpirySeconds(expiry);
//                 return await _redisDb.KeyExpireAsync(redisKey, expirySeconds);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error setting expiry for key: {key}");
//                 return false;
//             }
//         }

//         // Get thời gian hết hạn còn lại của một key trong Redis cache
//         public async Task<TimeSpan?> KeyExpiryGetAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 return await _redisDb.KeyTimeToLiveAsync(redisKey);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting expiry for key: {key}");
//                 return null;
//             }
//         }
//         #endregion

//         #region String Operations
//         // Set một giá trị string vào Redis cache với thời gian hết hạn tùy chọn
//         public async Task<bool> KeyStringSetAsync<T>(string key, T value, TimeSpan? expiry = null)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var jsonString = ValueToString(value);
//                 var expirySeconds = GetExpirySeconds(expiry);
//                 return await _redisDb.StringSetAsync(redisKey, jsonString, expirySeconds);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error setting string value for key: {key}");
//                 return false;
//             }
//         }

//         // Get một giá trị string từ Redis cache theo key
//         public async Task<string> KeyStringGetAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var value = await _redisDb.StringGetAsync(redisKey);
//                 return value.ToString();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting string value for key: {key}");
//                 return null;
//             }
//         }

//         // Delete một key string khỏi Redis cache
//         public async Task<bool> KeyStringDeleteAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 return await _redisDb.KeyDeleteAsync(redisKey);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error deleting string key: {key}");
//                 return false;
//             }
//         }
//         #endregion

//         #region Hash Operations
//         // Set một cặp field-value vào Redis Hash
//         public async Task<bool> KeyHashFieldSetAsync<T>(string key, string hashField, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.HashSetAsync(redisKey, hashField, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error setting hash field {hashField} for key: {key}");
//                 return false;
//             }
//         }

//         // Get giá trị của một field từ Redis Hash
//         public async Task<string> KeyHashFieldGetAsync(string key, string hashField)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var value = await _redisDb.HashGetAsync(redisKey, hashField);
//                 return value.ToString();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting hash field {hashField} for key: {key}");
//                 return null;
//             }
//         }

//         // Get tất cả các cặp field-value từ Redis Hash
//         public async Task<Dictionary<string, string>> KeyAllHashFieldsGetAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var hashEntries = await _redisDb.HashGetAllAsync(redisKey);
//                 var result = new Dictionary<string, string>();
//                 foreach (var entry in hashEntries)
//                 {
//                     result.Add(entry.Name.ToString(), entry.Value.ToString());
//                 }
//                 return result;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting all hash fields for key: {key}");
//                 return null;
//             }
//         }

//         // Set nhiều cặp field-value vào Redis Hash với thời gian hết hạn tùy chọn
//         public async Task<bool> KeyHashFieldsSetAsync<T>(string key, IDictionary<string, T> hashFields, TimeSpan? expiry = null)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var field in hashFields)
//                 {
//                     string jsonString = ValueToString(field.Value);
//                     tasks.Add(_redisDb.HashSetAsync(redisKey, field.Key, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 await Task.WhenAll(tasks);


//                 var expirySeconds = GetExpirySeconds(expiry);
//                 await _redisDb.KeyExpireAsync(redisKey, expirySeconds);


//                 return true;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error setting multiple hash fields for key: {key}");
//                 return false;
//             }
//         }

//         // Delete nhiều field khỏi Redis Hash
//         public async Task<bool> KeyHashFieldsDeleteAsync(string key, IEnumerable<string> hashFields)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var field in hashFields)
//                 {
//                     tasks.Add(_redisDb.HashDeleteAsync(redisKey, field));
//                 }

//                 // Thực thi tất cả các task
//                 await Task.WhenAll(tasks);
//                 return true;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error deleting hash fields for key: {key}");
//                 return false;
//             }
//         }

//         // Override tất cả các field trong Redis Hash với các cặp field-value mới
//         public async Task<bool> KeyHashFieldsOverrideSetAsync(string key, IDictionary<string, string> newHashFields)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 // Xóa tất cả các field cũ
//                 await _redisDb.KeyDeleteAsync(redisKey);
//                 // Thêm các field mới
//                 return await KeyHashFieldsSetAsync(key, newHashFields);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error overriding hash for key: {key}");
//                 return false;
//             }
//         }
//         #endregion

//         #region List Operations
//         // Get một dải giá trị từ Redis List
//         public async Task<string[]> KeyListRangeGetAsync(string key, long start = 0, long stop = -1)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var values = await _redisDb.ListRangeAsync(redisKey, start, stop);
//                 return Array.ConvertAll(values, x => x.ToString());
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting range from list: {key}");
//                 return null;
//             }
//         }

//         // Push một giá trị vào bên trái của Redis List
//         public async Task<long> KeyListLeftPushAsync<T>(string key, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.ListLeftPushAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error pushing value to list: {key}");
//                 return -1;
//             }
//         }

//         // Pop một giá trị từ bên trái của Redis List
//         public async Task<string> KeyListLeftPopAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var value = await _redisDb.ListLeftPopAsync(redisKey);
//                 return value.ToString();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error popping value from list: {key}");
//                 return null;
//             }
//         }

//         // Push nhiều giá trị vào bên trái của Redis List
//         public async Task<long> KeyListLeftPushAsync<T>(string key, IEnumerable<T> values)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<long>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var value in values)
//                 {
//                     string jsonString = ValueToString(value);
//                     tasks.Add(_redisDb.ListLeftPushAsync(redisKey, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Sum();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error pushing multiple values to list: {key}");
//                 return -1;
//             }
//         }

//         // Push một giá trị vào bên phải của Redis List
//         public async Task<long> KeyListRightPushAsync<T>(string key, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.ListRightPushAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error pushing value to list: {key}");
//                 return -1;
//             }
//         }

//         // Pop một giá trị từ bên phải của Redis List
//         public async Task<string> KeyListRightPopAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var value = await _redisDb.ListRightPopAsync(redisKey);
//                 return value.ToString();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error popping value from list: {key}");
//                 return null;
//             }
//         }

//         // Push nhiều giá trị vào bên phải của Redis List
//         public async Task<long> KeyListRightPushAsync<T>(string key, IEnumerable<T> values)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<long>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var value in values)
//                 {
//                     string jsonString = ValueToString(value);
//                     tasks.Add(_redisDb.ListRightPushAsync(redisKey, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Sum();
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error pushing multiple values to list: {key}");
//                 return -1;
//             }
//         }

//         // Override tất cả các giá trị trong Redis List với các giá trị mới
//         public async Task<bool> KeyListOverrideSetAsync<T>(string key, IEnumerable<T> newValues)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 // Xóa list cũ
//                 await _redisDb.KeyDeleteAsync(redisKey);
//                 // Thêm các giá trị mới
//                 var values = newValues.Select(v => ValueToString(v));
//                 var result = await KeyListLeftPushAsync(key, values);
//                 return result >= 0;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error overriding list for key: {key}");
//                 return false;
//             }
//         }

//         // Delete một giá trị khỏi Redis List
//         public async Task<long> KeyListRemoveAsync<T>(string key, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.ListRemoveAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing value from list: {key}");
//                 return -1;
//             }
//         }

//         // Delete nhiều giá trị khỏi Redis List
//         public async Task<long> KeyListRemoveAsync<T>(string key, IEnumerable<T> values)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var batch = _redisDb.CreateBatch();
//                 var count = 0;
//                 foreach (var value in values)
//                 {
//                     string jsonString = ValueToString(value);
//                     batch.ListRemoveAsync(redisKey, jsonString);
//                     count++;
//                 }
//                 await batch.ExecuteAsync("BATCH");
//                 return count;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing multiple values from list: {key}");
//                 return -1;
//             }
//         }
//         #endregion

//         #region Set Operations
//         // Add một giá trị vào Redis Set
//         public async Task<bool> KeySetAddAsync<T>(string key, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.SetAddAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error adding value to set: {key}");
//                 return false;
//             }
//         }

//         // Get tất cả các thành viên của Redis Set
//         public async Task<string[]> KeySetGetAsync(string key)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var values = await _redisDb.SetMembersAsync(redisKey);
//                 return Array.ConvertAll(values, x => x.ToString());
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting members from set: {key}");
//                 return null;
//             }
//         }

//         // Add nhiều giá trị vào Redis Set
//         public async Task<long> KeySetAddAsync<T>(string key, IEnumerable<T> values)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<bool>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var value in values)
//                 {
//                     string jsonString = ValueToString(value);
//                     tasks.Add(_redisDb.SetAddAsync(redisKey, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Count(x => x);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error adding multiple values to set: {key}");
//                 return -1;
//             }
//         }

//         // Remove nhiều giá trị khỏi Redis Set
//         public async Task<long> KeySetRemoveAsync<T>(string key, IEnumerable<T> values)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<bool>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var value in values)
//                 {
//                     string jsonString = ValueToString(value);
//                     tasks.Add(_redisDb.SetRemoveAsync(redisKey, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Count(x => x);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing multiple values from set: {key}");
//                 return -1;
//             }
//         }

//         // Remove một thành viên khỏi Redis Set
//         public async Task<bool> KeySetRemoveAsync<T>(string key, T value)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(value);
//                 return await _redisDb.SetRemoveAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing member from set: {key}");
//                 return false;
//             }
//         }

//         // Override tất cả các giá trị trong Redis Set với các giá trị mới
//         public async Task<bool> KeySetOverrideSetAsync<T>(string key, IEnumerable<T> newValues)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 // Xóa set cũ
//                 await _redisDb.KeyDeleteAsync(redisKey);
//                 // Thêm các giá trị mới
//                 var values = newValues.Select(v => ValueToString(v));
//                 var result = await KeySetAddAsync(key, values);
//                 return result >= 0;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error overriding set for key: {key}");
//                 return false;
//             }
//         }
//         #endregion

//         #region Sorted Set Operations
//         // Add một thành viên với điểm số vào Redis Sorted Set
//         public async Task<bool> KeySortedSetAddAsync<T>(string key, T member, double score)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(member);
//                 return await _redisDb.SortedSetAddAsync(redisKey, jsonString, score);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error adding member to sorted set: {key}");
//                 return false;
//             }
//         }

//         // Get điểm số của một thành viên trong Redis Sorted Set
//         public async Task<double?> KeySortedSetScoreGetAsync<T>(string key, T member)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 string jsonString = ValueToString(member);
//                 return await _redisDb.SortedSetScoreAsync(redisKey, jsonString);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting score from sorted set: {key}");
//                 return null;
//             }
//         }

//         // Get range of members by score from a Redis Sorted Set
//         public async Task<string[]> KeySortedSetRangeByScoreGetAsync(string key, double start = double.NegativeInfinity, double stop = double.PositiveInfinity)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var values = await _redisDb.SortedSetRangeByScoreAsync(redisKey, start, stop);
//                 return Array.ConvertAll(values, x => x.ToString());
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error getting range from sorted set: {key}");
//                 return null;
//             }
//         }

//         // Add multiple members with scores to a Redis Sorted Set
//         public async Task<long> KeySortedSetAddAsync<T>(string key, IDictionary<T, double> members)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<bool>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var member in members)
//                 {
//                     string jsonString = ValueToString(member.Key);
//                     tasks.Add(_redisDb.SortedSetAddAsync(redisKey, jsonString, member.Value));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Count(x => x);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error adding multiple members to sorted set: {key}");
//                 return -1;
//             }
//         }

//         // Remove multiple members from a Redis Sorted Set
//         public async Task<long> KeySortedSetRemoveAsync<T>(string key, IEnumerable<T> members)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 var tasks = new List<Task<bool>>();

//                 // Tạo các task riêng lẻ thay vì sử dụng batch
//                 foreach (var member in members)
//                 {
//                     string jsonString = ValueToString(member);
//                     tasks.Add(_redisDb.SortedSetRemoveAsync(redisKey, jsonString));
//                 }

//                 // Thực thi tất cả các task
//                 var results = await Task.WhenAll(tasks);
//                 return results.Count(x => x);
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error removing multiple members from sorted set: {key}");
//                 return -1;
//             }
//         }

//         // Override tất cả các thành viên trong Redis Sorted Set với các thành viên và điểm số mới
//         public async Task<bool> KeySortedSetOverrideSetAsync<T>(string key, IDictionary<T, double> newMembers)
//         {
//             try
//             {
//                 var redisKey = GetRedisKey(key);
//                 // Xóa sorted set cũ
//                 await _redisDb.KeyDeleteAsync(redisKey);
//                 // Thêm các member mới
//                 var result = await KeySortedSetAddAsync(key, newMembers);
//                 return result >= 0;
//             }
//             catch (Exception ex)
//             {
//                 _logger.LogError(ex, $"Error overriding sorted set for key: {key}");
//                 return false;
//             }
//         }
//         #endregion

//     }
// }
// using Newtonsoft.Json;
// using PodcastService.BusinessLogic.Helpers.JsonHelpers;

// namespace PodcastService.BusinessLogic.DTOs.Cache
// {
//     public class AccountStatusCache
//     {
//         public required int Id { get; set; }
//         public required string Email { get; set; }
//         public required string FullName { get; set; }
//         public string? MainImageFileKey { get; set; }
//         public int RoleId { get; set; }
//         public bool IsVerified { get; set; }
//         public int ViolationLevel { get; set; }
//         public int ViolationPoint { get; set; }
//         public string? PodcasterProfileName { get; set; }
//         public bool? PodcasterProfileIsVerified { get; set; }
//         public bool HasVerifiedPodcasterProfile { get; set; }

//         [JsonConverter(typeof(NullableDateTimeJsonConverter))]
//         public required DateTime? PodcasterProfileVerifiedAt { get; set; }

//         [JsonConverter(typeof(NullableDateTimeJsonConverter))]
//         public DateTime? LastViolationPointChanged { get; set; }

//         [JsonConverter(typeof(NullableDateTimeJsonConverter))]
//         public DateTime? LastViolationLevelChanged { get; set; }

//         [JsonConverter(typeof(NullableDateTimeJsonConverter))]
//         public DateTime? DeactivatedAt { get; set; }
//     }

// }

// using System.Linq.Expressions;

// namespace PodcastService.DataAccess.Repositories.interfaces
// {
//     public interface IGenericRepository<T> where T : class
//     {
//         IQueryable<T> FindAll(Expression<Func<T, bool>>? predicate = null, params Expression<Func<T, object>>[] includeProperties);
//         public IQueryable<T> FindAll(Expression<Func<T, bool>>? predicate = null, Func<IQueryable<T>, IQueryable<T>>? includeFunc = null);
//         Task<T?> FindByIdAsync(object id, params Expression<Func<T, object>>[] includeProperties);
//         Task<T?> FindByIdAsync(object id, Func<IQueryable<T>, IQueryable<T>>? includeFunc = null);

//         Task<T?> FindByIdWithPaths(object id, params string[] includePaths);
//         IQueryable<T> FindAllWithPaths(Expression<Func<T, bool>>? predicate = null, params string[] includePaths);
//         Task<T?> CreateAsync(T entity);
//         Task<T?> UpdateAsync(object id, T entity);
//         Task<T?> DeleteAsync(object id);
//     }
// }
// using PodcastService.DataAccess.Repositories.interfaces;
// using Microsoft.EntityFrameworkCore;
// using PodcastService.DataAccess.Data;
// using System.Linq.Expressions;

// namespace PodcastService.DataAccess.Repositories
// {
//     public class GenericRepository<T> : IGenericRepository<T> where T : class
//     {
//         private readonly AppDbContext _appDbContext;
//         internal DbSet<T> _dbSet;

//         public GenericRepository(AppDbContext appDbContext)
//         {
//             _appDbContext = appDbContext;
//             _dbSet = _appDbContext.Set<T>();
//         }

//         public IQueryable<T> FindAll(Expression<Func<T, bool>>? predicate = null, params Expression<Func<T, object>>[] includeProperties)
//         {
//             IQueryable<T> items = _appDbContext.Set<T>();

//             if (includeProperties.Any())
//             {
//                 foreach (var property in includeProperties)
//                 {
//                     items = items.Include(property);
//                 }
//             }


//             if (predicate != null)
//             {
//                 items = items.Where(predicate);
//             }

//             return items;
//         }

//         public IQueryable<T> FindAll(
//             Expression<Func<T, bool>>? predicate = null,
//             Func<IQueryable<T>, IQueryable<T>>? includeFunc = null)
//         {
//             IQueryable<T> items = _appDbContext.Set<T>();

//             // Apply includes using func
//             if (includeFunc != null)
//             {
//                 items = includeFunc(items);
//             }

//             // Apply predicate
//             if (predicate != null)
//             {
//                 items = items.Where(predicate);
//             }

//             return items;
//         }
//         public async Task<T?> FindByIdAsync(object id, params Expression<Func<T, object>>[] includeProperties)
//         {
//             var query = _appDbContext.Set<T>().AsQueryable();

//             // Apply includes
//             foreach (var includeProperty in includeProperties)
//             {
//                 query = query.Include(includeProperty);
//             }

//             // Get Id property info
//             var idProperty = typeof(T).GetProperty("Id");
//             if (idProperty == null)
//                 throw new InvalidOperationException($"Entity {typeof(T).Name} does not have an 'Id' property");

//             var idType = Nullable.GetUnderlyingType(idProperty.PropertyType) ?? idProperty.PropertyType;

//             // Handle specific problematic types that can't be compared implicitly
//             if (idType == typeof(Guid))
//             {
//                 var guidId = id is Guid g ? g :
//                             Guid.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to Guid", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<Guid>(e, "Id") == guidId);
//             }

//             if (idType == typeof(DateTime))
//             {
//                 var dateId = id is DateTime dt ? dt :
//                             DateTime.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to DateTime", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<DateTime>(e, "Id") == dateId);
//             }

//             if (idType == typeof(decimal))
//             {
//                 var decId = id is decimal dec ? dec :
//                            decimal.TryParse(id?.ToString(), out var parsed) ? parsed :
//                            throw new ArgumentException($"Cannot convert '{id}' to decimal", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<decimal>(e, "Id") == decId);
//             }

//             // For safe types (int, long, string, etc.) - use generic approach
//             try
//             {
//                 var convertedId = Convert.ChangeType(id, idType);

//                 // Create expression: e => e.Id == convertedId
//                 var parameter = Expression.Parameter(typeof(T), "e");
//                 var property = Expression.Property(parameter, "Id");
//                 var constant = Expression.Constant(convertedId, idProperty.PropertyType);
//                 var equality = Expression.Equal(property, constant);
//                 var lambda = Expression.Lambda<Func<T, bool>>(equality, parameter);

//                 return await query.FirstOrDefaultAsync(lambda);
//             }
//             catch (Exception ex)
//             {
//                 throw new ArgumentException($"Cannot convert id '{id}' of type {id?.GetType().Name} to {idType.Name}: {ex.Message}", nameof(id));
//             }
//         }

//         public async Task<T?> FindByIdAsync(object id, Func<IQueryable<T>, IQueryable<T>>? includeFunc = null)
//         {
//             var query = _appDbContext.Set<T>().AsQueryable();

//             // Apply includes using func
//             if (includeFunc != null)
//             {
//                 query = includeFunc(query);
//             }

//             // Get Id property info
//             var idProperty = typeof(T).GetProperty("Id");
//             if (idProperty == null)
//                 throw new InvalidOperationException($"Entity {typeof(T).Name} does not have an 'Id' property");

//             var idType = Nullable.GetUnderlyingType(idProperty.PropertyType) ?? idProperty.PropertyType;

//             // Handle specific problematic types that can't be compared implicitly
//             if (idType == typeof(Guid))
//             {
//                 var guidId = id is Guid g ? g :
//                             Guid.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to Guid", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<Guid>(e, "Id") == guidId);
//             }

//             if (idType == typeof(DateTime))
//             {
//                 var dateId = id is DateTime dt ? dt :
//                             DateTime.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to DateTime", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<DateTime>(e, "Id") == dateId);
//             }

//             if (idType == typeof(decimal))
//             {
//                 var decId = id is decimal dec ? dec :
//                            decimal.TryParse(id?.ToString(), out var parsed) ? parsed :
//                            throw new ArgumentException($"Cannot convert '{id}' to decimal", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<decimal>(e, "Id") == decId);
//             }

//             // For safe types (int, long, string, etc.) - use generic approach
//             try
//             {
//                 var convertedId = Convert.ChangeType(id, idType);

//                 // Create expression: e => e.Id == convertedId
//                 var parameter = Expression.Parameter(typeof(T), "e");
//                 var property = Expression.Property(parameter, "Id");
//                 var constant = Expression.Constant(convertedId, idProperty.PropertyType);
//                 var equality = Expression.Equal(property, constant);
//                 var lambda = Expression.Lambda<Func<T, bool>>(equality, parameter);
//                 return await query.FirstOrDefaultAsync(lambda);
//             }
//             catch (Exception ex)
//             {
//                 throw new ArgumentException($"Cannot convert id '{id}' of type {id?.GetType().Name} to {idType.Name}: {ex.Message}", nameof(id));
//             }
//         }

//         public async Task<T?> FindByIdWithPaths(object id, params string[] includePaths)
//         {
//             IQueryable<T> query = _dbSet;

//             // Apply string-based includes
//             foreach (var include in includePaths)
//             {
//                 query = query.Include(include);
//             }

//             // Get Id property info
//             var idProperty = typeof(T).GetProperty("Id");
//             if (idProperty == null)
//                 throw new InvalidOperationException($"Entity {typeof(T).Name} does not have an 'Id' property");

//             var idType = Nullable.GetUnderlyingType(idProperty.PropertyType) ?? idProperty.PropertyType;

//             // Handle specific problematic types that can't be compared implicitly
//             if (idType == typeof(Guid))
//             {
//                 var guidId = id is Guid g ? g :
//                             Guid.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to Guid", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<Guid>(e, "Id") == guidId);
//             }

//             if (idType == typeof(DateTime))
//             {
//                 var dateId = id is DateTime dt ? dt :
//                             DateTime.TryParse(id?.ToString(), out var parsed) ? parsed :
//                             throw new ArgumentException($"Cannot convert '{id}' to DateTime", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<DateTime>(e, "Id") == dateId);
//             }

//             if (idType == typeof(decimal))
//             {
//                 var decId = id is decimal dec ? dec :
//                            decimal.TryParse(id?.ToString(), out var parsed) ? parsed :
//                            throw new ArgumentException($"Cannot convert '{id}' to decimal", nameof(id));
//                 return await query.FirstOrDefaultAsync(e => EF.Property<decimal>(e, "Id") == decId);
//             }

//             // For safe types (int, long, string, etc.) - use generic approach
//             try
//             {
//                 var convertedId = Convert.ChangeType(id, idType);

//                 // Create expression: e => e.Id == convertedId
//                 var parameter = Expression.Parameter(typeof(T), "e");
//                 var property = Expression.Property(parameter, "Id");
//                 var constant = Expression.Constant(convertedId, idProperty.PropertyType);
//                 var equality = Expression.Equal(property, constant);
//                 var lambda = Expression.Lambda<Func<T, bool>>(equality, parameter);

//                 return await query.FirstOrDefaultAsync(lambda);
//             }
//             catch (Exception ex)
//             {
//                 throw new ArgumentException($"Cannot convert id '{id}' of type {id?.GetType().Name} to {idType.Name}: {ex.Message}", nameof(id));
//             }
//         }

//         public IQueryable<T> FindAllWithPaths(Expression<Func<T, bool>>? predicate = null, params string[] includePaths)
//         {
//             IQueryable<T> query = _dbSet;

//             // Apply string-based includes
//             foreach (var include in includePaths)
//             {
//                 query = query.Include(include);
//             }

//             if (predicate != null)
//             {
//                 query = query.Where(predicate);
//             }

//             return query;
//         }

//         public async Task<T?> CreateAsync(T entity)
//         {
//             var entry = await _dbSet.AddAsync(entity);
//             await _appDbContext.SaveChangesAsync();
//             return entry.Entity;
//         }

//         public async Task<T?> UpdateAsync(object id, T entity)
//         {
//             if (entity == null)
//             {
//                 throw new ArgumentNullException(nameof(entity), "Entity không được để null.");
//             }

//             var existingEntity = await _dbSet.FindAsync(id);
//             if (existingEntity == null)
//             {
//                 Console.WriteLine($"Không tìm thấy entity với ID {id}.");
//                 return null;
//             }

//             _appDbContext.Entry(existingEntity).State = EntityState.Detached;
//             _appDbContext.Entry(entity).State = EntityState.Modified;


//             await _appDbContext.SaveChangesAsync();
//             return entity;
//         }

//         public async Task<T?> DeleteAsync(object id)
//         {
//             var entity = await _dbSet.FindAsync(id);
//             if (entity != null)
//             {
//                 _dbSet.Remove(entity);
//                 await _appDbContext.SaveChangesAsync();
//                 return entity;
//             }

//             return null;
//         }



//     }


// }

// "BackgroundJobs": {
//       // All time max query metric update jobs - chạy hàng ngày lúc 00:00
//       "PodcasterAllTimeMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         "Description": "[Background Job] Update podcaster all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/podcaster-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:podcaster:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       "ShowAllTimeMaxQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         "Description": "[Background Job] Update show all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/show-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:show:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       "ChannelAllTimeMaxQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         "Description": "[Background Job] Update channel all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/channel-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:channel:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       // Temporal max query metric update jobs - chạy mỗi 12 giờ
//       "PodcasterTemporal7dMaxQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         "Description": "[Background Job] Update podcaster temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/podcaster-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:podcaster:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       "ShowTemporal7dMaxQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         "Description": "[Background Job] Update show temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/show-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:show:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       "ChannelTemporal7dMaxQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         "Description": "[Background Job] Update channel temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/channel-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:channel:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       // System preferences query metric update job - chạy mỗi 2 giờ
//       "SystemPreferencesTemporal30dQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 */2 * * *", // Chạy mỗi 2 giờ
//         "Description": "[Background Job] Update system preferences temporal 30-day query metric - Every 2 hours",
//         "ConsulLockKey": "background-jobs/system-preferences-temporal-30d-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:system_preferences:temporal_30d",
//         "RedisKeyTTLSeconds": 7200 // 2 hours
//       },
//       // User preferences query metric update job - chạy mỗi 2 giờ
//       "UserPreferencesTemporal30dQueryMetricUpdateJob": {
//     "IsEnabled": true,
//         "CronExpression": "0 0 */2 * * *", // Chạy mỗi 2 giờ
//         "Description": "[Background Job] Update user preferences temporal 30-day query metric - Every 2 hours",
//         "ConsulLockKey": "background-jobs/user-preferences-temporal-30d-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:user_preferences:temporal_30d",
//         "RedisKeyTTLSeconds": 7200 // 2 hours
//       }
//     },

//    using Newtonsoft.Json.Linq;

// namespace PodcastService.Common.AppConfigurations.BusinessSetting.interfaces
// {
//     public interface IBackgroundJobsConfig
//     {
//         BackgroundJob PodcasterAllTimeMaxQueryMetricUpdateJob { get; }
//         BackgroundJob PodcasterTemporal7dMaxQueryMetricUpdateJob { get; }
//         BackgroundJob ShowAllTimeMaxQueryMetricUpdateJob { get; }
//         BackgroundJob ChannelAllTimeMaxQueryMetricUpdateJob { get; }
//         BackgroundJob ShowTemporal7dMaxQueryMetricUpdateJob { get; }
//         BackgroundJob ChannelTemporal7dMaxQueryMetricUpdateJob { get; }
//         BackgroundJob SystemPreferencesTemporal30dQueryMetricUpdateJob { get; }
//         BackgroundJob UserPreferencesTemporal30dQueryMetricUpdateJob { get; }

//     }

//     public class BackgroundJob
//     {
//         public string? CronExpression { get; set; }
//         public string Description { get; set; }
//         public bool IsEnabled { get; set; }
//         public string ConsulLockKey { get; set; }
//         public int ConsulLockTTLSeconds { get; set; }
//         public int ConsulLockRenewalIntervalSeconds { get; set; }
//         public string? RedisKeyName { get; set; }
//         public int? RedisKeyTTLSeconds { get; set; }
//     }
// }
//  using Microsoft.Extensions.Configuration;
// using Newtonsoft.Json.Linq;
// using Newtonsoft.Json;
// using PodcastService.Common.AppConfigurations.BusinessSetting.interfaces;
// using PodcastService.Common.AppConfigurations.FilePath;

// namespace PodcastService.Common.AppConfigurations.BusinessSetting
// {
//     public class BackgroundJobsConfigModel
//     {
//         public BackgroundJob PodcasterAllTimeMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob PodcasterTemporal7dMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob ShowAllTimeMaxQueryMetricUpdateJob { get; set; }
//         public BackgroundJob ChannelAllTimeMaxQueryMetricUpdateJob { get; set; }
//         public BackgroundJob ShowTemporal7dMaxQueryMetricUpdateJob { get; set; }
//         public BackgroundJob ChannelTemporal7dMaxQueryMetricUpdateJob { get; set; }
//         public BackgroundJob SystemPreferencesTemporal30dQueryMetricUpdateJob { get; set; }
//         public BackgroundJob UserPreferencesTemporal30dQueryMetricUpdateJob { get; set; }
//     }
//     public class BackgroundJobsConfig : IBackgroundJobsConfig
//     {
//         public BackgroundJob PodcasterAllTimeMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob PodcasterTemporal7dMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob ShowAllTimeMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob ChannelAllTimeMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob ShowTemporal7dMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob ChannelTemporal7dMaxQueryMetricUpdateJob { get; }
//         public BackgroundJob SystemPreferencesTemporal30dQueryMetricUpdateJob { get; }
//         public BackgroundJob UserPreferencesTemporal30dQueryMetricUpdateJob { get; }


//         public BackgroundJobsConfig(IConfiguration configuration)
//         {
//             var backgroundJobsConfig = configuration.GetSection("BusinessSettings:BackgroundJobs").Get<BackgroundJobsConfigModel>();
//             PodcasterAllTimeMaxQueryMetricUpdateJob = backgroundJobsConfig?.PodcasterAllTimeMaxQueryMetricUpdateJob;
//             PodcasterTemporal7dMaxQueryMetricUpdateJob = backgroundJobsConfig?.PodcasterTemporal7dMaxQueryMetricUpdateJob;
//             ShowAllTimeMaxQueryMetricUpdateJob = backgroundJobsConfig?.ShowAllTimeMaxQueryMetricUpdateJob;
//             ChannelAllTimeMaxQueryMetricUpdateJob = backgroundJobsConfig?.ChannelAllTimeMaxQueryMetricUpdateJob;
//             ShowTemporal7dMaxQueryMetricUpdateJob = backgroundJobsConfig?.ShowTemporal7dMaxQueryMetricUpdateJob;
//             ChannelTemporal7dMaxQueryMetricUpdateJob = backgroundJobsConfig?.ChannelTemporal7dMaxQueryMetricUpdateJob;
//             SystemPreferencesTemporal30dQueryMetricUpdateJob = backgroundJobsConfig?.SystemPreferencesTemporal30dQueryMetricUpdateJob;
//             UserPreferencesTemporal30dQueryMetricUpdateJob = backgroundJobsConfig?.UserPreferencesTemporal30dQueryMetricUpdateJob;
//         }
//     }
// }

// namespace PodcastService.BusinessLogic.Enums.Podcast
// {
//     public enum PodcastChannelStatusEnum
//     {
//         Unpublished = 1,
//         Published = 2,
//     }
// }
// namespace PodcastService.BusinessLogic.Enums.Podcast
// {
//     public enum PodcastEpisodePublishReviewSessionStatusEnum
//     {
//         PendingReview = 1,
//         Discard = 2,
//         Accepted = 3,
//         Rejected = 4
//     }
// }
// namespace PodcastService.BusinessLogic.Enums.Podcast
// {
//     public enum PodcastEpisodeStatusEnum
//     {
//         Draft = 1,
//         PendingReview = 2,
//         PendingEditRequired = 3,
//         ReadyToRelease = 4,
//         Published = 5,
//         TakenDown = 6,
//         Removed = 7,
//         AudioProcessing = 8
//     }
// }
// namespace PodcastService.BusinessLogic.Enums.Podcast
// {
//     public enum PodcastShowStatusEnum
//     {
//         Draft = 1,
//         ReadyToRelease = 2,
//         Published = 3,
//         TakenDown = 4,
//         Removed = 5
//     }
// }

// "BackgroundJobs": {
//     // === Query Metric Update Jobs Configurations ===
//     // All time max query metric update jobs - chạy hàng ngày lúc 00:00
//     "PodcasterAllTimeMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update podcaster all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/podcaster-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:podcaster:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       "ShowAllTimeMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update show all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/show-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:show:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       "ChannelAllTimeMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 0 * * *", // Chạy mỗi ngày lúc 00:00
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update channel all-time max query metric - Daily 00:00",
//         "ConsulLockKey": "background-jobs/channel-all-time-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:channel:all_time_max",
//         "RedisKeyTTLSeconds": 86400 // 1 day
//       },
//       // Temporal max query metric update jobs - chạy mỗi 12 giờ
//       "PodcasterTemporal7dMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update podcaster temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/podcaster-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:podcaster:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       "ShowTemporal7dMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update show temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/show-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:show:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       "ChannelTemporal7dMaxQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 */12 * * *", // Chạy mỗi 12 giờ
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update channel temporal 7-day max query metric - Every 12 hours",
//         "ConsulLockKey": "background-jobs/channel-temporal-7d-max-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:channel:temporal_7d_max",
//         "RedisKeyTTLSeconds": 43200 // 12 hours
//       },
//       // System preferences query metric update job - chạy mỗi 2 giờ
//       "SystemPreferencesTemporal30dQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 */2 * * *", // Chạy mỗi 2 giờ
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update system preferences temporal 30-day query metric - Every 2 hours",
//         "ConsulLockKey": "background-jobs/system-preferences-temporal-30d-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:system_preferences:temporal_30d",
//         "RedisKeyTTLSeconds": 7200 // 2 hours
//       },
//       // User preferences query metric update job - chạy mỗi 2 giờ
//       "UserPreferencesTemporal30dQueryMetricUpdateJob": {
//         "IsEnabled": true,
//         "CronExpression": "0 0 */2 * * *", // Chạy mỗi 2 giờ
//         // "CronExpression": "*/10 * * * * *", // Chạy mỗi 10 giây (dùng cho môi trường test)
//         "Description": "[Background Job] Update user preferences temporal 30-day query metric - Every 2 hours",
//         "ConsulLockKey": "background-jobs/user-preferences-temporal-30d-query-metric-update",
//         "ConsulLockTTLSeconds": 120, // Consul TTL chỉ cho phép từ 10 giây trở lên
//         "ConsulLockRenewalIntervalSeconds": 4,
//         "RedisKeyName": "query:metric:user_preferences:temporal_30d",
//         "RedisKeyTTLSeconds": 7200 // 2 hours
//       },
// }

// using Microsoft.EntityFrameworkCore;
// using Microsoft.Extensions.Logging;
// using Newtonsoft.Json;
// using Newtonsoft.Json.Linq;
// using PodcastService.Common.AppConfigurations.App.interfaces;
// using PodcastService.Common.AppConfigurations.FilePath.interfaces;
// using PodcastService.DataAccess.Data;
// using PodcastService.DataAccess.UOW;
// using PodcastService.Infrastructure.Configurations.Payos.interfaces;
// using PodcastService.BusinessLogic.Helpers.AuthHelpers;
// using PodcastService.BusinessLogic.Helpers.FileHelpers;
// using PodcastService.DataAccess.Repositories.interfaces;
// using PodcastService.DataAccess.Entities.SqlServer;
// using PodcastService.BusinessLogic.Services.CrossServiceServices.QueryServices;
// using PodcastService.Infrastructure.Services.Redis;
// using PodcastService.Common.AppConfigurations.BusinessSetting.interfaces;
// using PodcastService.BusinessLogic.DTOs.Cache.QueryMetric;
// using PodcastService.BusinessLogic.Helpers.DateHelpers;
// using PodcastService.BusinessLogic.Enums.Podcast;
// using System.Linq.Expressions;
// using PodcastService.BusinessLogic.Models.CrossService;
// using PodcastService.BusinessLogic.DTOs.Account;

// namespace PodcastService.BusinessLogic.Services.DbServices.CachingServices
// {
//     public class QueryMetricCachingService
//     {
//         // LOGGER
//         private readonly ILogger<QueryMetricCachingService> _logger;

//         // CONFIG
//         public readonly IAppConfig _appConfig;
//         private readonly IFilePathConfig _filePathConfig;
//         private readonly IPayosConfig _payosConfig;
//         private readonly IBackgroundJobsConfig _jobsConfig;

//         // DB CONTEXT
//         private readonly AppDbContext _appDbContext;

//         // HELPERS
//         private readonly BcryptHelper _bcryptHelper;
//         private readonly JwtHelper _jwtHelper;
//         private readonly FileIOHelper _fileIOHelper;
//         private readonly DateHelper _dateHelper;

//         // UNIT OF WORK
//         private readonly IUnitOfWork _unitOfWork;

//         // REPOSITORIES
//         private readonly IGenericRepository<PodcastChannel> _podcastChannelGenericRepository;
//         private readonly IGenericRepository<PodcastChannelStatusTracking> _podcastChannelStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastChannelHashtag> _podcastChannelHashtagGenericRepository;
//         private readonly IGenericRepository<Hashtag> _hashtagGenericRepository;
//         private readonly IGenericRepository<PodcastShow> _podcastShowGenericRepository;
//         private readonly IGenericRepository<PodcastShowStatusTracking> _podcastShowStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastShowHashtag> _podcastShowHashtagGenericRepository;
//         private readonly IGenericRepository<PodcastEpisode> _podcastEpisodeGenericRepository;
//         private readonly IGenericRepository<PodcastShowReview> _podcastShowReviewGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeStatusTracking> _podcastEpisodeStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeHashtag> _podcastEpisodeHashtagGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeLicense> _podcastEpisodeLicenseGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeLicenseType> _podcastEpisodeLicenseTypeGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishReviewSession> _podcastEpisodePublishReviewSessionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishDuplicateDetection> _podcastEpisodePublishDuplicateDetectionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeIllegalContentTypeMarking> _podcastEpisodeIllegalContentTypeMarkingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodePublishReviewSessionStatusTracking> _podcastEpisodePublishReviewSessionStatusTrackingGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeListenSession> _podcastEpisodeListenSessionGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeListenSessionHlsEnckeyRequestToken> _podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository;

//         private readonly HttpServiceQueryClient _httpServiceQueryClient;

//         private readonly RedisSharedCacheService _redisSharedCacheService;


//         public QueryMetricCachingService(
//             ILogger<QueryMetricCachingService> logger,
//             AppDbContext appDbContext,
//             BcryptHelper bcryptHelper,
//             DateHelper dateHelper,
//             JwtHelper jwtHelper,
//             IUnitOfWork unitOfWork,


//             FileIOHelper fileIOHelper,
//             IFilePathConfig filePathConfig,
//             IAppConfig appConfig,
//             IPayosConfig payosConfig,
//             IBackgroundJobsConfig jobsConfig,

//             HttpServiceQueryClient httpServiceQueryClient,

//             IGenericRepository<PodcastChannel> podcastChannelGenericRepository,
//             IGenericRepository<PodcastChannelStatusTracking> podcastChannelStatusTrackingGenericRepository,
//             IGenericRepository<PodcastChannelHashtag> podcastChannelHashtagGenericRepository,
//             IGenericRepository<Hashtag> hashtagGenericRepository,
//             IGenericRepository<PodcastShow> podcastShowGenericRepository,
//             IGenericRepository<PodcastShowStatusTracking> podcastShowStatusTrackingGenericRepository,
//             IGenericRepository<PodcastShowHashtag> podcastShowHashtagGenericRepository,
//             IGenericRepository<PodcastEpisode> podcastEpisodeGenericRepository,
//             IGenericRepository<PodcastShowReview> podcastShowReviewGenericRepository,
//             IGenericRepository<PodcastEpisodeStatusTracking> podcastEpisodeStatusTrackingGenericRepository,
//             IGenericRepository<PodcastEpisodeHashtag> podcastEpisodeHashtagGenericRepository,
//             IGenericRepository<PodcastEpisodeLicense> podcastEpisodeLicenseGenericRepository,
//             IGenericRepository<PodcastEpisodeLicenseType> podcastEpisodeLicenseTypeGenericRepository,
//             IGenericRepository<PodcastEpisodePublishReviewSession> podcastEpisodePublishReviewSessionGenericRepository,
//             IGenericRepository<PodcastEpisodePublishDuplicateDetection> podcastEpisodePublishDuplicateDetectionGenericRepository,
//             IGenericRepository<PodcastEpisodeIllegalContentTypeMarking> podcastEpisodeIllegalContentTypeMarkingGenericRepository,
//             IGenericRepository<PodcastEpisodePublishReviewSessionStatusTracking> podcastEpisodePublishReviewSessionStatusTrackingGenericRepository,
//             IGenericRepository<PodcastEpisodeListenSession> podcastEpisodeListenSessionGenericRepository,
//             IGenericRepository<PodcastEpisodeListenSessionHlsEnckeyRequestToken> podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository,


//             RedisSharedCacheService redisSharedCacheService
//             )
//         {
//             _logger = logger;
//             _appDbContext = appDbContext;
//             _bcryptHelper = bcryptHelper;
//             _dateHelper = dateHelper;
//             _jwtHelper = jwtHelper;
//             _unitOfWork = unitOfWork;


//             _fileIOHelper = fileIOHelper;
//             _filePathConfig = filePathConfig;
//             _appConfig = appConfig;
//             _payosConfig = payosConfig;
//             _jobsConfig = jobsConfig;

//             _httpServiceQueryClient = httpServiceQueryClient;

//             _podcastChannelGenericRepository = podcastChannelGenericRepository;
//             _podcastChannelStatusTrackingGenericRepository = podcastChannelStatusTrackingGenericRepository;
//             _podcastChannelHashtagGenericRepository = podcastChannelHashtagGenericRepository;
//             _hashtagGenericRepository = hashtagGenericRepository;
//             _podcastShowGenericRepository = podcastShowGenericRepository;
//             _podcastShowStatusTrackingGenericRepository = podcastShowStatusTrackingGenericRepository;
//             _podcastShowHashtagGenericRepository = podcastShowHashtagGenericRepository;
//             _podcastEpisodeGenericRepository = podcastEpisodeGenericRepository;
//             _podcastShowReviewGenericRepository = podcastShowReviewGenericRepository;
//             _podcastEpisodeStatusTrackingGenericRepository = podcastEpisodeStatusTrackingGenericRepository;
//             _podcastEpisodeHashtagGenericRepository = podcastEpisodeHashtagGenericRepository;
//             _podcastEpisodeLicenseGenericRepository = podcastEpisodeLicenseGenericRepository;
//             _podcastEpisodeLicenseTypeGenericRepository = podcastEpisodeLicenseTypeGenericRepository;
//             _podcastEpisodePublishReviewSessionGenericRepository = podcastEpisodePublishReviewSessionGenericRepository;
//             _podcastEpisodePublishDuplicateDetectionGenericRepository = podcastEpisodePublishDuplicateDetectionGenericRepository;
//             _podcastEpisodeIllegalContentTypeMarkingGenericRepository = podcastEpisodeIllegalContentTypeMarkingGenericRepository;
//             _podcastEpisodePublishReviewSessionStatusTrackingGenericRepository = podcastEpisodePublishReviewSessionStatusTrackingGenericRepository;
//             _podcastEpisodeListenSessionGenericRepository = podcastEpisodeListenSessionGenericRepository;
//             _podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository = podcastEpisodeListenSessionHlsEnckeyRequestTokenGenericRepository;

//             _redisSharedCacheService = redisSharedCacheService;
//         }


//         private async Task<(List<TEntity> entities, int daysBack, int distinctCount)> QueryIncrementalWithMinDistinctAsync<TEntity, TKey>(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack,
//             Func<DateTime, DateTime, Expression<Func<TEntity, bool>>> predicateFactory,
//             Func<IQueryable<TEntity>, IQueryable<TEntity>> includeFunc,
//             Func<TEntity, TKey> distinctKeySelector
//         ) where TEntity : class
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();
//             int currentDaysBack = 0;

//             List<TEntity> accumulatedEntities = new List<TEntity>();
//             int distinctCount = 0;

//             Console.WriteLine($"[QueryIncremental] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Lấy repository tương ứng với TEntity
//             var repository = GetRepositoryForEntity<TEntity>();

//             while (currentDaysBack < maxDaysBack)
//             {
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[QueryIncremental] Querying batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Tạo predicate cho batch hiện tại
//                 var predicate = predicateFactory(batchStartDate, batchEndDate);

//                 // Query batch
//                 var batchEntities = await repository.FindAll(
//                     predicate: predicate,
//                     includeFunc: includeFunc
//                 ).ToListAsync();

//                 Console.WriteLine($"[QueryIncremental] Batch returned {batchEntities.Count} entities");

//                 // Nếu batch rỗng, dừng vì không còn data
//                 if (batchEntities.Count == 0)
//                 {
//                     Console.WriteLine($"[QueryIncremental] No more data found, stopping at {currentDaysBack + daysBatchSize} days back");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedEntities.AddRange(batchEntities);

//                 // Tính distinct count
//                 distinctCount = accumulatedEntities
//                     .Select(distinctKeySelector)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[QueryIncremental] Total accumulated: {accumulatedEntities.Count}, Distinct: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[QueryIncremental] Condition met: {distinctCount} distinct entities in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[QueryIncremental] Completed - Total entities: {accumulatedEntities.Count}, Days back: {currentDaysBack}, Distinct: {distinctCount}");

//             return (accumulatedEntities, currentDaysBack, distinctCount);
//         }

//         /// <summary>
//         /// Helper method để lấy repository phù hợp với entity type
//         /// </summary>
//         private IGenericRepository<TEntity> GetRepositoryForEntity<TEntity>() where TEntity : class
//         {
//             var entityType = typeof(TEntity);

//             if (entityType == typeof(PodcastEpisodeListenSession))
//                 return (IGenericRepository<TEntity>)_podcastEpisodeListenSessionGenericRepository;

//             // if (entityType == typeof(PodcastShowFollow))
//             //     return (IGenericRepository<TEntity>)_podcastShowFollowGenericRepository; // Cần thêm repository này vào constructor

//             // if (entityType == typeof(PodcastChannelFavorite))
//             //     return (IGenericRepository<TEntity>)_podcastChannelFavoriteGenericRepository; // Cần thêm repository này vào constructor

//             throw new NotSupportedException($"Repository for entity type {entityType.Name} is not registered");
//         }

//         private async Task<(List<AccountFollowedPodcastShowDTO> follows, int daysBack, int distinctCount)> GetAccountNewFollowedPodcastShowAsync(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack
//         )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFollowedPodcastShow] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ follows từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFollowedPodcastShows",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcastShow",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["accountFollowedPodcastShows"].ToObject<List<AccountFollowedPodcastShowDTO>>();

//             Console.WriteLine($"[GetAccountNewFollowedPodcastShow] Total follows from UserService: {allFollows.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFollowedPodcastShowDTO> accumulatedFollows = new List<AccountFollowedPodcastShowDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);


//                 // Filter follows trong batch hiện tại
//                 var batchFollows = allFollows
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();


//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFollows.Count == 0)
//                 {
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFollows.AddRange(batchFollows);

//                 // Tính distinct show count
//                 distinctCount = accumulatedFollows
//                     .Select(f => f.PodcastShowId)
//                     .Distinct()
//                     .Count();

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     break;
//                 }
//             }

//             return (accumulatedFollows, currentDaysBack, distinctCount);
//         }

//         private async Task<(List<AccountFavoritedPodcastChannelDTO> favorites, int daysBack, int distinctCount)> GetAccountNewFavoritedPodcastChannelAsync(
//     int daysBatchSize,
//     int minDistinctEntityCount,
//     int minDaysBack,
//     int maxDaysBack
// )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ favorites từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFavoritedPodcastChannels",
//                 QueryType = "findall",
//                 EntityType = "AccountFavoritedPodcastChannel",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFavorites = result.Results["accountFavoritedPodcastChannels"].ToObject<List<AccountFavoritedPodcastChannelDTO>>();

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Total favorites from UserService: {allFavorites.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFavoritedPodcastChannelDTO> accumulatedFavorites = new List<AccountFavoritedPodcastChannelDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Processing batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Filter favorites trong batch hiện tại
//                 var batchFavorites = allFavorites
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Batch returned {batchFavorites.Count} favorites");

//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFavorites.Count == 0)
//                 {
//                     Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] No more data found in this batch, stopping");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFavorites.AddRange(batchFavorites);

//                 // Tính distinct channel count
//                 distinctCount = accumulatedFavorites
//                     .Select(f => f.PodcastChannelId)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Total accumulated: {accumulatedFavorites.Count}, Distinct channels: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Condition met: {distinctCount} distinct channels in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[GetAccountNewFavoritedPodcastChannel] Completed - Total favorites: {accumulatedFavorites.Count}, Days back: {currentDaysBack}, Distinct channels: {distinctCount}");

//             return (accumulatedFavorites, currentDaysBack, distinctCount);
//         }

//         private async Task<(List<AccountFollowedPodcasterDTO> follows, int daysBack, int distinctCount)> GetAccountNewFollowedPodcasterAsync(
//             int daysBatchSize,
//             int minDistinctEntityCount,
//             int minDaysBack,
//             int maxDaysBack
//         )
//         {
//             var now = _dateHelper.GetNowByAppTimeZone();

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Starting - BatchSize={daysBatchSize}, MinDistinct={minDistinctEntityCount}, MinDays={minDaysBack}, MaxDays={maxDaysBack}");

//             // Query toàn bộ follows từ UserService (vì không support date range filter)
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "accountFollowedPodcasters",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcaster",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };

//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["accountFollowedPodcasters"].ToObject<List<AccountFollowedPodcasterDTO>>();

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Total follows from UserService: {allFollows.Count}");

//             // Incremental filtering logic
//             int currentDaysBack = 0;
//             List<AccountFollowedPodcasterDTO> accumulatedFollows = new List<AccountFollowedPodcasterDTO>();
//             int distinctCount = 0;

//             while (currentDaysBack < maxDaysBack)
//             {
//                 // Tính date range cho batch hiện tại
//                 var batchStartDate = now.AddDays(-(currentDaysBack + daysBatchSize));
//                 var batchEndDate = now.AddDays(-currentDaysBack);

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Processing batch: from {batchStartDate:yyyy-MM-dd} to {batchEndDate:yyyy-MM-dd}");

//                 // Filter follows trong batch hiện tại
//                 var batchFollows = allFollows
//                     .Where(f => f.CreatedAt >= batchStartDate && f.CreatedAt < batchEndDate)
//                     .ToList();

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Batch returned {batchFollows.Count} follows");

//                 // Nếu batch rỗng, dừng vì không còn data cũ hơn
//                 if (batchFollows.Count == 0)
//                 {
//                     Console.WriteLine($"[GetAccountNewFollowedPodcaster] No more data found in this batch, stopping");
//                     break;
//                 }

//                 // Accumulate
//                 accumulatedFollows.AddRange(batchFollows);

//                 // Tính distinct podcaster count
//                 distinctCount = accumulatedFollows
//                     .Select(f => f.PodcasterId)
//                     .Distinct()
//                     .Count();

//                 Console.WriteLine($"[GetAccountNewFollowedPodcaster] Total accumulated: {accumulatedFollows.Count}, Distinct podcasters: {distinctCount}");

//                 // Di chuyển sang batch tiếp theo
//                 currentDaysBack += daysBatchSize;

//                 // Kiểm tra điều kiện dừng
//                 if (distinctCount >= minDistinctEntityCount && currentDaysBack >= minDaysBack)
//                 {
//                     Console.WriteLine($"[GetAccountNewFollowedPodcaster] Condition met: {distinctCount} distinct podcasters in {currentDaysBack} days");
//                     break;
//                 }
//             }

//             Console.WriteLine($"[GetAccountNewFollowedPodcaster] Completed - Total follows: {accumulatedFollows.Count}, Days back: {currentDaysBack}, Distinct podcasters: {distinctCount}");

//             return (accumulatedFollows, currentDaysBack, distinctCount);
//         }


//         /////////////////////////////////////////////////////////////
//         public async Task UpdatePodcasterAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // Logic to update podcaster all-time max query metric goes here
//                 // truy danh sách podcaster đã được isVerified = true từ UserService
//                 // 1: lấy MaxTotalFollow từ cột totalFollow của tất cả các podcaster trong bảng PodcasterProfile của UserService
//                 // 2: lấy MaxListenCount từ cột ListenCount của tất cả các podcaster trong bảng PodcasterProfile của UserService
//                 // 3: lấy MaxRatingTerm trong đó RatingTerm của mỗi podcaster được tính bằng: RT = AverageRating * log(RatingCount + 1)
//                 // 4: lấy MaxAge từ cột verifiedAt của tất cả các podcaster trong bảng PodcasterProfile của UserService tính từ thời điểm hiện tại
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                 {
//                     new BatchQueryItem
//                     {
//                         Key = "verifiedPodcasterProfiles",
//                         QueryType = "findall",
//                         EntityType = "PodcasterProfile",
//                         Parameters = JObject.FromObject(new
//                         {
//                             IsVerified = true
//                         })
//                     }
//                 }
//                 };
//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var verifiedPodcasterProfiles = result.Results["verifiedPodcasterProfiles"].ToObject<List<PodcasterProfileDTO>>();

//                 var podcasterAllTimeMaxQueryMetric = new PodcasterAllTimeMaxQueryMetric
//                 {
//                     MaxTotalFollow = verifiedPodcasterProfiles
//                         .Select(g => g.TotalFollow)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxListenCount = verifiedPodcasterProfiles
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),
//                     MaxAge = verifiedPodcasterProfiles
//                         .Select(pp => pp.VerifiedAt.HasValue
//                             ? (int)(_dateHelper.GetNowByAppTimeZone() - pp.VerifiedAt.Value).TotalDays
//                             : 0)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxRatingTerm = verifiedPodcasterProfiles
//                         .Select(pp => pp.AverageRating * Math.Log(pp.RatingCount + 1))
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, podcasterAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdatePodcasterAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }
//         public async Task UpdatePodcasterTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // truy danh sách podcaster đã được isVerified = true từ UserService
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity >= 5 podcaster) từ bảng PodcastEpisodeListenSession liên kết với PodcasterProfile của UserService
//                 // 2: lấy MaxNewFollow 7 ngày tối thiểu về trước (entity >= 5 podcaster) từ bảng AccountFollowedPodcaster của UserService
//                 // 3: lấy MaxGrowth 7 ngày tối thiểu về trước (entity >= 5 podcaster) trong đó Growth của mỗi podcaster được tính bằng: G = NewListenSessionCount + NewFollowCount
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                 {
//                     new BatchQueryItem
//                     {
//                         Key = "verifiedPodcasterProfiles",
//                         QueryType = "findall",
//                         EntityType = "PodcasterProfile",
//                         Parameters = JObject.FromObject(new
//                         {
//                             IsVerified = true
//                         })
//                     }
//                 }
//                 };
//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var verifiedPodcasterProfiles = result.Results["verifiedPodcasterProfiles"].ToObject<List<PodcasterProfileDTO>>();
//                 var verifiedPodcasterIds = verifiedPodcasterProfiles
//                     .Select(pp => pp.AccountId)
//                     .ToHashSet();

//                 var (newFollows, followDaysBack, followDistinctCount) = await GetAccountNewFollowedPodcasterAsync(
//                     daysBatchSize: 7,
//                     minDistinctEntityCount: 5,
//                     minDaysBack: 7,
//                     maxDaysBack: 365
//                 );

//                 newFollows = newFollows
//                     .Where(f => verifiedPodcasterIds.Contains(f.PodcasterId))
//                     .ToList();


//                 var (listenSessions, listenDaysBack, distinctShowCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc: q => q.Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShow.PodcasterId
//                     );

//                 listenSessions = listenSessions
//                     .Where(ls => verifiedPodcasterIds.Contains(ls.PodcastEpisode.PodcastShow.PodcasterId))
//                     .ToList();

//                 var podcasterIdsInListenSessions = listenSessions
//                     .Select(ls => ls.PodcastEpisode.PodcastShow.PodcasterId)
//                     .Distinct();

//                 var podcasterIdsInFollows = newFollows
//                     .Select(nf => nf.PodcasterId)
//                     .Distinct();

//                 var allTemporalPodcasterIds = podcasterIdsInListenSessions
//                     .Union(podcasterIdsInFollows)
//                     .Distinct()
//                     .ToList();

//                 var podcasterTemporal7dMaxQueryMetric = new PodcasterTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new
//                         {
//                             PodcasterId = g.Key,
//                             NewListenSessionCount = g.Count()
//                         })
//                         .Select(x => x.NewListenSessionCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxNewFollow = newFollows
//                         .GroupBy(afps => afps.PodcasterId)
//                         .Select(g => new
//                         {
//                             PodcasterId = g.Key,
//                             NewFollowCount = g.Count()
//                         })
//                         .Select(x => x.NewFollowCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxGrowth = allTemporalPodcasterIds
//                         .Select(podcasterId =>
//                         {
//                             var newListenSessionCount = listenSessions
//                                 .Count(ls => ls.PodcastEpisode.PodcastShow.PodcasterId == podcasterId);
//                             var newFollowCount = newFollows
//                                 .Count(nf => nf.PodcasterId == podcasterId);
//                             return newListenSessionCount + newFollowCount;
//                         })
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, podcasterTemporal7dMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));

//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdatePodcasterTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }

//         public async Task UpdateShowAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update show all-time max query metric goes here
//                 // 1: lấy MaxTotalFollow từ cột totalFollow của tất cả các show (chưa bị xoá / Removed) trong bảng PodcastShow
//                 // 2: lấy MaxListenCount từ cột ListenCount của tất cả các show (chưa bị xoá / Removed) trong bảng PodcastShow
//                 // 3: lấy MaxRatingTerm trong đó RatingTerm của mỗi show được tính bằng: RT = AverageRating * log(RatingCount + 1)
//                 // 4: lấy ra LastUpdated là hiện tại
//                 // 5: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 var allTimeShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps => ps.DeletedAt == null &&
//                     // trạng thái cuối cùng không phải là Removed
//                     ps.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed
//                     ,
//                     includeFunc: null
//                 ).ToListAsync();

//                 var showAllTimeMaxQueryMetric = new ShowAllTimeMaxQueryMetric
//                 {
//                     MaxTotalFollow = allTimeShows
//                         .Select(g => g.TotalFollow)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxListenCount = allTimeShows
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     MaxRatingTerm = allTimeShows
//                         .Select(ps => ps.AverageRating * Math.Log(ps.RatingCount + 1))
//                         .DefaultIfEmpty(0)
//                         .Max(),


//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, showAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateShowAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }
//         }

//         public async Task UpdateChannelAllTimeMaxQueryMetric()
//         {
//             try
//             {
//                 // Logic to update channel all-time max query metric goes here
//                 // 1: lấy MaxListenCount từ cột ListenCount của tất cả các channel (chưa bị xoá) trong bảng PodcastChannel
//                 // 2: lấy MaxTotalFavorite từ cột TotalFavorite của tất cả các channel (chưa bị xoá) trong bảng PodcastChannel
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;


//                 var allTimeChannels = await _podcastChannelGenericRepository.FindAll(
//                     predicate: pc => pc.DeletedAt == null,
//                     includeFunc: null
//                 ).ToListAsync();
//                 var channelAllTimeMaxQueryMetric = new ChannelAllTimeMaxQueryMetric
//                 {
//                     MaxListenCount = allTimeChannels
//                         .Select(g => g.ListenCount)
//                         .DefaultIfEmpty(0)
//                         .Max(),
//                     MaxTotalFavorite = allTimeChannels
//                         .Select(g => g.TotalFavorite)
//                         .DefaultIfEmpty(0)
//                         .Max(),

//                     LastUpdated = _dateHelper.GetNowByAppTimeZone()
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, channelAllTimeMaxQueryMetric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateChannelAllTimeMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateShowTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // NGUYÊN TẮT TRONG TEMPORAL: 7 NGÀY LÀ TỐI THIẾU CÓ THỂ HƠN 7 NGÀY MIỄN SAO ĐẢM BẢO MIN RECORD ENTITY = 5 SHOW / CHANNEL / PODCASTER
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update show temporal 7-day max query metric goes here
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng PodcastShowListenSession
//                 // 2: lấy MaxNewFollow 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng AccountFollowedPodcastShow
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;


//                 // ============ Query MaxNewListenSession ============
//                 var (listenSessions, listenDaysBack, distinctShowCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, Guid>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault().PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc: q => q.Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShowId
//                     );

//                 // Tính MaxNewListenSession
//                 int maxNewListenSession = 0;
//                 if (listenSessions.Count > 0)
//                 {
//                     var listenSessionByShow = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShowId)
//                         .Select(g => new
//                         {
//                             PodcastShowId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewListenSession = listenSessionByShow
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Query MaxNewFollow ============
//                 var (follows, followDaysBack, distinctShowCountForFollow) =
//                     await GetAccountNewFollowedPodcastShowAsync(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365
//                     );

//                 int maxNewFollow = 0;
//                 if (follows.Count > 0)
//                 {
//                     var followsByShow = follows
//                         .GroupBy(f => f.PodcastShowId)
//                         .Select(g => new { PodcastShowId = g.Key, Count = g.Count() })
//                         .ToList();

//                     maxNewFollow = followsByShow.Select(x => x.Count).Max();
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, followDaysBack);

//                 var metric = new ShowTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = maxNewListenSession,
//                     MaxNewFollow = maxNewFollow,
//                     LastUpdated = now
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));


//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateShowTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateChannelTemporal7dMaxQueryMetric()
//         {
//             try
//             {
//                 // NGUYÊN TẮT TRONG TEMPORAL: 7 NGÀY LÀ TỐI THIẾU CÓ THỂ HƠN 7 NGÀY MIỄN SAO ĐẢM BẢO MIN RECORD ENTITY = 5 SHOW / CHANNEL / PODCASTER
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update channel temporal 7-day max query metric goes here
//                 // 1: lấy MaxNewListenSession 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng PodcastShowListenSession
//                 // 2: lấy MaxNewFavorite 7 ngày tối thiểu về trước (entity phải min =5 nếu không đủ 5 trong 7 ngày thì lấy quá đến khi đủ 5 entity) từ bảng AccountFavoritedPodcastChannel
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job
//                 var cacheKey = _jobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Query MaxNewListenSession ============
//                 // Query listen sessions từ episodes thuộc channels
//                 var (listenSessions, listenDaysBack, distinctChannelCountForListen) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, Guid?>(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault().PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null,
//                         includeFunc: q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastChannel),
//                         distinctKeySelector: pes => pes.PodcastEpisode.PodcastShow.PodcastChannelId
//                     );

//                 // Tính MaxNewListenSession
//                 int maxNewListenSession = 0;
//                 if (listenSessions.Count > 0)
//                 {
//                     var listenSessionByChannel = listenSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcastChannelId)
//                         .Select(g => new
//                         {
//                             PodcastChannelId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewListenSession = listenSessionByChannel
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Query MaxNewFavorite ============
//                 var (favorites, favoriteDaysBack, distinctChannelCountForFavorite) =
//                     await GetAccountNewFavoritedPodcastChannelAsync(
//                         daysBatchSize: 7,
//                         minDistinctEntityCount: 5,
//                         minDaysBack: 7,
//                         maxDaysBack: 365
//                     );

//                 int maxNewFavorite = 0;
//                 if (favorites.Count > 0)
//                 {
//                     var favoritesByChannel = favorites
//                         .GroupBy(f => f.PodcastChannelId)
//                         .Select(g => new
//                         {
//                             PodcastChannelId = g.Key,
//                             Count = g.Count()
//                         })
//                         .ToList();

//                     maxNewFavorite = favoritesByChannel
//                         .Select(x => x.Count)
//                         .Max();
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, favoriteDaysBack);

//                 var metric = new ChannelTemporal7dMaxQueryMetric
//                 {
//                     MaxNewListenSession = maxNewListenSession,
//                     MaxNewFavorite = maxNewFavorite,
//                     LastUpdated = now
//                 };

//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateChannelTemporal7dMaxQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateSystemPreferencesTemporal30dQueryMetric()
//         {
//             try
//             {
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update System Preferences temporal 30-day goes here
//                 // 1: lấy ListenedPodcastCategories[] 30 ngày tối thiểu về trước (entity phải 4 categories min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 4 categories) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcastCategoriy có categoryId, listenCount, PodcastSubCategories (có subcategoryId, listenCount)
//                 // 2: lấy ListenedPodcaster[] 30 ngày tối thiểu về trước (entity phải 2 podcasters min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 2 podcasters) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcaster có podcasterId, listenCount
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Query ListenedPodcastCategory[] ============
//                 var (listenSessions, listenDaysBack, distinctCategoryCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int?>(
//                         daysBatchSize: 15,
//                         minDistinctEntityCount: 4,
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc:
//                         q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         //     .ThenInclude(ps => ps.PodcastShowHashtags)
//                         //     .ThenInclude(psh => psh.Hashtag),
//                         distinctKeySelector: pes =>
//                             pes.PodcastCategoryId
//                     );

//                 List<SystemListenedPodcastCategory> ListenedPodcastCategories = new List<SystemListenedPodcastCategory>();
//                 if (listenSessions.Count > 0)
//                 {
//                     var categoryListenCounts = listenSessions
//                         .Where(pes => pes.PodcastCategoryId.HasValue)
//                         .GroupBy(pes => pes.PodcastCategoryId.Value)
//                         .Select(g => new SystemListenedPodcastCategory
//                         {
//                             PodcastCategoryId = g.Key,
//                             ListenCount = g.Count(),
//                             PodcastSubCategories = g
//                                 .Where(pes => pes.PodcastSubCategoryId.HasValue)
//                                 .GroupBy(pes => pes.PodcastSubCategoryId.Value)
//                                 .Select(sg => new SystemListenedPodcastSubCategory
//                                 {
//                                     PodcastSubCategoryId = sg.Key,
//                                     ListenCount = sg.Count()
//                                 })
//                                 .OrderByDescending(x => x.ListenCount)
//                                 .ToList()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     ListenedPodcastCategories = categoryListenCounts;
//                 }

//                 // ============ Query ListenedPodcaster[] ============
//                 var (listenSessionsForPodcaster, listenDaysBackForPodcaster, distinctPodcasterCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 15,
//                         minDistinctEntityCount: 2,
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null || (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                                 pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null
//                             )),
//                         includeFunc:
//                         q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes =>
//                             pes.PodcastEpisode.PodcastShow.PodcasterId
//                     );

//                 List<SystemListenedPodcaster> ListenedPodcasters = new List<SystemListenedPodcaster>();
//                 if (listenSessionsForPodcaster.Count > 0)
//                 {
//                     var podcasterListenCounts = listenSessionsForPodcaster
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new SystemListenedPodcaster
//                         {
//                             PodcasterId = g.Key,
//                             ListenCount = g.Count()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     ListenedPodcasters = podcasterListenCounts;
//                 }

//                 // ============ Lưu vào cache ============
//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 int finalDaysBack = Math.Max(listenDaysBack, listenDaysBackForPodcaster);
//                 var metric = new SystemPreferencesTemporal30dQueryMetric
//                 {
//                     ListenedPodcastCategories = ListenedPodcastCategories,
//                     ListenedPodcasters = ListenedPodcasters,
//                     LastUpdated = now
//                 };
//                 await _redisSharedCacheService.KeySetAsync(cacheKey, metric, TimeSpan.FromSeconds(cacheTTL ?? 3600));
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateSystemPreferencesTemporal30dQueryMetric failed, error: " + ex.Message);
//             }

//         }

//         public async Task UpdateUserPreferencesTemporal30dQueryMetric()
//         {
//             try
//             {
//                 // điều kiện của listen session: isContentRemoved = false
//                 // Logic to update User Preferences temporal 30-day goes here
//                 // group by AccountId và đưa vào field UserId trong DTO
//                 // 1: lấy ListenedPodcastCategories[] 30 ngày tối thiểu về trước (entity phải 4 categories min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 4 categories) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcastCategoriy có categoryId, listenCount, PodcastSubCategories (có subcategoryId, listenCount)
//                 // 2: lấy ListenedPodcaster[] 30 ngày tối thiểu về trước (entity phải 2 podcasters min nếu không đủ trong 30 ngày thì lấy quá đến khi đủ 2 podcasters) từ bảng PodcastEpisodeListenSession
//                 //  --> lấy nhiều object ListenedPodcaster có podcasterId, listenCount
//                 // 3: lấy ra LastUpdated là hiện tại
//                 // 4: lưu vào DTO sau đó đưa vào cache
//                 // 4: cập nhật vào cache key trong config của job

//                 var cacheKey = _jobsConfig.UserPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                 var cacheTTL = _jobsConfig.UserPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyTTLSeconds;

//                 // ============ Bước 1: Query để lấy distinct users (không giới hạn số lượng user) ============
//                 var (allUserListenSessions, _, distinctUserCount) =
//                     await QueryIncrementalWithMinDistinctAsync<PodcastEpisodeListenSession, int>(
//                         daysBatchSize: 30,
//                         minDistinctEntityCount: 1, // Lấy tất cả users, không giới hạn
//                         minDaysBack: 30,
//                         maxDaysBack: 365,
//                         predicateFactory: (startDate, endDate) => pes =>
//                             pes.CreatedAt >= startDate &&
//                             pes.CreatedAt < endDate &&
//                             pes.IsContentRemoved == false &&
//                             pes.PodcastEpisode.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastEpisodeStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastEpisodeStatusId != (int)PodcastEpisodeStatusEnum.Removed &&
//                             pes.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                             pes.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(pet => pet.CreatedAt)
//                             .FirstOrDefault()
//                             .PodcastShowStatusId != (int)PodcastShowStatusEnum.Removed &&
//                             (pes.PodcastEpisode.PodcastShow.PodcastChannel == null ||
//                              (pes.PodcastEpisode.PodcastShow.PodcastChannel != null &&
//                               pes.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null)),
//                         includeFunc: q => q
//                             .Include(pes => pes.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow),
//                         distinctKeySelector: pes => pes.AccountId
//                     );

//                 // Extract distinct user IDs
//                 var distinctUserIds = allUserListenSessions
//                     .Select(pes => pes.AccountId)
//                     .Distinct()
//                     .ToList();

//                 Console.WriteLine($"[UserPreferencesTemporal30d] Found {distinctUserIds.Count} distinct users");

//                 // ============ Bước 2: Xử lý từng user ============
//                 var now = _dateHelper.GetNowByAppTimeZone();

//                 foreach (var userId in distinctUserIds)
//                 {
//                     // Filter sessions của user này
//                     var userSessions = allUserListenSessions
//                         .Where(pes => pes.AccountId == userId)
//                         .ToList();

//                     // ============ Incremental filtering cho Categories (min 4) ============
//                     int daysBatchSize = 15;
//                     int currentDaysBackForCategory = 0;
//                     int minDaysBack = 30;
//                     int maxDaysBack = 365;

//                     List<PodcastEpisodeListenSession> accumulatedCategorySessions = new List<PodcastEpisodeListenSession>();
//                     int distinctCategoryCount = 0;

//                     while (currentDaysBackForCategory < maxDaysBack)
//                     {
//                         var batchStartDate = now.AddDays(-(currentDaysBackForCategory + daysBatchSize));
//                         var batchEndDate = now.AddDays(-currentDaysBackForCategory);

//                         var batchSessions = userSessions
//                             .Where(pes => pes.CreatedAt >= batchStartDate && pes.CreatedAt < batchEndDate)
//                             .ToList();

//                         if (batchSessions.Count == 0)
//                             break;

//                         accumulatedCategorySessions.AddRange(batchSessions);

//                         distinctCategoryCount = accumulatedCategorySessions
//                             .Where(pes => pes.PodcastCategoryId.HasValue)
//                             .Select(pes => pes.PodcastCategoryId.Value)
//                             .Distinct()
//                             .Count();

//                         currentDaysBackForCategory += daysBatchSize;

//                         if (distinctCategoryCount >= 4 && currentDaysBackForCategory >= minDaysBack)
//                             break;
//                     }

//                     // Tính ListenedPodcastCategories
//                     var listenedCategories = accumulatedCategorySessions
//                         .Where(pes => pes.PodcastCategoryId.HasValue)
//                         .GroupBy(pes => pes.PodcastCategoryId.Value)
//                         .Select(g => new UserListenedPodcastCategory
//                         {
//                             PodcastCategoryId = g.Key,
//                             ListenCount = g.Count(),
//                             PodcastSubCategories = g
//                                 .Where(pes => pes.PodcastSubCategoryId.HasValue)
//                                 .GroupBy(pes => pes.PodcastSubCategoryId.Value)
//                                 .Select(sg => new UserListenedPodcastSubCategory
//                                 {
//                                     PodcastSubCategoryId = sg.Key,
//                                     ListenCount = sg.Count()
//                                 })
//                                 .OrderByDescending(x => x.ListenCount)
//                                 .ToList()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     // ============ Incremental filtering cho Podcasters (min 2) ============
//                     int currentDaysBackForPodcaster = 0;
//                     List<PodcastEpisodeListenSession> accumulatedPodcasterSessions = new List<PodcastEpisodeListenSession>();
//                     int distinctPodcasterCount = 0;

//                     while (currentDaysBackForPodcaster < maxDaysBack)
//                     {
//                         var batchStartDate = now.AddDays(-(currentDaysBackForPodcaster + daysBatchSize));
//                         var batchEndDate = now.AddDays(-currentDaysBackForPodcaster);

//                         var batchSessions = userSessions
//                             .Where(pes => pes.CreatedAt >= batchStartDate && pes.CreatedAt < batchEndDate)
//                             .ToList();

//                         if (batchSessions.Count == 0)
//                             break;

//                         accumulatedPodcasterSessions.AddRange(batchSessions);

//                         distinctPodcasterCount = accumulatedPodcasterSessions
//                             .Select(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                             .Distinct()
//                             .Count();

//                         currentDaysBackForPodcaster += daysBatchSize;

//                         if (distinctPodcasterCount >= 2 && currentDaysBackForPodcaster >= minDaysBack)
//                             break;
//                     }

//                     // Tính ListenedPodcasters
//                     var listenedPodcasters = accumulatedPodcasterSessions
//                         .GroupBy(pes => pes.PodcastEpisode.PodcastShow.PodcasterId)
//                         .Select(g => new UserListenedPodcaster
//                         {
//                             PodcasterId = g.Key,
//                             ListenCount = g.Count()
//                         })
//                         .OrderByDescending(x => x.ListenCount)
//                         .ToList();

//                     // ============ Lưu metric cho user ============
//                     var userMetric = new UserPreferencesTemporal30dQueryMetric
//                     {
//                         UserId = userId,
//                         ListenedPodcastCategories = listenedCategories,
//                         ListenedPodcasters = listenedPodcasters,
//                         LastUpdated = now
//                     };

//                     // Cache riêng cho từng user
//                     await _redisSharedCacheService.KeySetAsync(cacheKey, userMetric, TimeSpan.FromSeconds(cacheTTL ?? 86400));

//                 }

//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine("\n" + ex.StackTrace + "\n");
//                 throw new Exception("UpdateUserPreferencesTemporal30dQueryMetric failed, error: " + ex.Message);
//             }
//         }
//     }
// }

// using Microsoft.EntityFrameworkCore;
// using Microsoft.Extensions.Logging;
// using PodcastService.Common.AppConfigurations.App.interfaces;
// using PodcastService.Common.AppConfigurations.FilePath.interfaces;
// using PodcastService.Common.AppConfigurations.BusinessSetting.interfaces;
// using PodcastService.DataAccess.Data;
// using PodcastService.DataAccess.UOW;
// using PodcastService.DataAccess.Repositories.interfaces;
// using PodcastService.DataAccess.Entities.SqlServer;
// using PodcastService.BusinessLogic.Helpers.AuthHelpers;
// using PodcastService.BusinessLogic.Helpers.FileHelpers;
// using PodcastService.BusinessLogic.Helpers.DateHelpers;
// using PodcastService.BusinessLogic.Services.CrossServiceServices.QueryServices;
// using PodcastService.BusinessLogic.Services.DbServices.CachingServices;
// using PodcastService.Infrastructure.Services.Redis;
// using PodcastService.BusinessLogic.DTOs.Feed;
// using PodcastService.BusinessLogic.DTOs.Show.ListItems;
// using PodcastService.BusinessLogic.DTOs.Channel.ListItems;
// using PodcastService.BusinessLogic.DTOs.Category.ListItems;
// using PodcastService.BusinessLogic.DTOs.Category;
// using PodcastService.BusinessLogic.DTOs.Account;
// using PodcastService.BusinessLogic.DTOs.Episode;
// using PodcastService.BusinessLogic.DTOs.Show;
// using PodcastService.BusinessLogic.DTOs.Channel;
// using PodcastService.BusinessLogic.DTOs.Hashtag;
// using PodcastService.BusinessLogic.DTOs.Cache;
// using PodcastService.BusinessLogic.DTOs.Cache.QueryMetric;
// using PodcastService.BusinessLogic.Enums.Podcast;
// using PodcastService.BusinessLogic.Models.CrossService;
// using Newtonsoft.Json.Linq;

// namespace PodcastService.BusinessLogic.Services.DbServices.PodcastServices
// {
//     public class FeedService
//     {
//         // LOGGER
//         private readonly ILogger<FeedService> _logger;

//         // CONFIG
//         private readonly IAppConfig _appConfig;
//         private readonly IFilePathConfig _filePathConfig;
//         private readonly IBackgroundJobsConfig _backgroundJobsConfig;

//         // DB CONTEXT
//         private readonly AppDbContext _appDbContext;

//         // HELPERS
//         private readonly DateHelper _dateHelper;

//         // UNIT OF WORK
//         private readonly IUnitOfWork _unitOfWork;

//         // REPOSITORIES
//         private readonly IGenericRepository<PodcastChannel> _podcastChannelGenericRepository;
//         private readonly IGenericRepository<PodcastShow> _podcastShowGenericRepository;
//         private readonly IGenericRepository<PodcastEpisode> _podcastEpisodeGenericRepository;
//         private readonly IGenericRepository<PodcastEpisodeListenSession> _podcastEpisodeListenSessionGenericRepository;
//         private readonly IGenericRepository<PodcastChannelHashtag> _podcastChannelHashtagGenericRepository;
//         private readonly IGenericRepository<PodcastCategory> _podcastCategoryGenericRepository;
//         private readonly IGenericRepository<PodcastSubCategory> _podcastSubCategoryGenericRepository;
//         private readonly IGenericRepository<PodcastShowHashtag> _podcastShowHashtagGenericRepository;
//         // SERVICES
//         private readonly HttpServiceQueryClient _httpServiceQueryClient;
//         private readonly AccountCachingService _accountCachingService;
//         private readonly RedisSharedCacheService _redisSharedCacheService;

//         public FeedService(
//             ILogger<FeedService> logger,
//             AppDbContext appDbContext,
//             DateHelper dateHelper,
//             IUnitOfWork unitOfWork,
//             IGenericRepository<PodcastChannel> podcastChannelGenericRepository,
//             IGenericRepository<PodcastShow> podcastShowGenericRepository,
//             IGenericRepository<PodcastEpisode> podcastEpisodeGenericRepository,
//             IGenericRepository<PodcastEpisodeListenSession> podcastEpisodeListenSessionGenericRepository,
//             IGenericRepository<PodcastChannelHashtag> podcastChannelHashtagGenericRepository,
//             IGenericRepository<PodcastCategory> podcastCategoryGenericRepository,
//             IGenericRepository<PodcastSubCategory> podcastSubCategoryGenericRepository,
//             IGenericRepository<PodcastShowHashtag> podcastShowHashtagGenericRepository,

//             IFilePathConfig filePathConfig,
//             IAppConfig appConfig,
//             IBackgroundJobsConfig backgroundJobsConfig,
//             HttpServiceQueryClient httpServiceQueryClient,
//             AccountCachingService accountCachingService,
//             RedisSharedCacheService redisSharedCacheService)
//         {
//             _logger = logger;
//             _appDbContext = appDbContext;
//             _dateHelper = dateHelper;
//             _unitOfWork = unitOfWork;

//             _podcastChannelGenericRepository = podcastChannelGenericRepository;
//             _podcastShowGenericRepository = podcastShowGenericRepository;
//             _podcastEpisodeGenericRepository = podcastEpisodeGenericRepository;
//             _podcastEpisodeListenSessionGenericRepository = podcastEpisodeListenSessionGenericRepository;
//             _podcastChannelHashtagGenericRepository = podcastChannelHashtagGenericRepository;
//             _podcastCategoryGenericRepository = podcastCategoryGenericRepository;
//             _podcastSubCategoryGenericRepository = podcastSubCategoryGenericRepository;
//             _podcastShowHashtagGenericRepository = podcastShowHashtagGenericRepository;

//             _filePathConfig = filePathConfig;
//             _appConfig = appConfig;
//             _backgroundJobsConfig = backgroundJobsConfig;
//             _httpServiceQueryClient = httpServiceQueryClient;
//             _accountCachingService = accountCachingService;
//             _redisSharedCacheService = redisSharedCacheService;
//         }

//         #region Discovery Entry Point

//         public async Task<DiscoveryPodcastFeedDTO> GetDiscoveryPodcastFeedContentsAsync(AccountStatusCache? account = null)
//         {
//             try
//             {
//                 Console.WriteLine($"[GetDiscoveryPodcastFeed] Starting - Account: {(account != null ? $"UserId={account.Id}" : "Anonymous")}");

//                 // STEP 1: Load all cache metrics in parallel
//                 var (userPrefs, systemPrefs, cacheMetrics) = await LoadAllCacheMetricsAsync(account?.Id);

//                 // STEP 2: Initialize deduplication trackers
//                 var dedupShowIds = new HashSet<Guid>();
//                 var dedupChannelIds = new HashSet<Guid>();
//                 var dedupPodcasterIds = new HashSet<int>();

//                 // STEP 3: Build sections in order (following deduplication priority)
//                 var continueListening = await BuildDiscoveryContinueListeningSection(account?.Id);

//                 var basedOnYourTaste = await BuildDiscoveryBasedOnYourTasteSection(
//                     account?.Id, userPrefs, systemPrefs, dedupShowIds);

//                 var newReleases = await BuildDiscoveryNewReleasesSection(
//                     userPrefs, systemPrefs, dedupShowIds);

//                 var hotThisWeek = await BuildDiscoveryHotThisWeekSection(
//                     cacheMetrics, dedupShowIds, dedupChannelIds);

//                 var topSubCategory = await BuildDiscoveryTopSubCategorySection(
//                     account?.Id, userPrefs, systemPrefs, cacheMetrics, dedupShowIds);

//                 var topPodcasters = await BuildDiscoveryTopPodcastersSection(
//                     cacheMetrics, dedupPodcasterIds);

//                 var randomCategory = await BuildDiscoveryRandomCategorySection(
//                     userPrefs, systemPrefs, cacheMetrics, dedupShowIds);

//                 var talentedRookies = await BuildDiscoveryTalentedRookiesSection(
//                     cacheMetrics, dedupPodcasterIds);

//                 Console.WriteLine("[GetDiscoveryPodcastFeed] Completed successfully");

//                 return new DiscoveryPodcastFeedDTO
//                 {
//                     ContinueListening = continueListening ?? new DiscoveryPodcastFeedDTO.ContinueListeningDiscoveryPodcastFeedSection { ListenSessionList = new List<DiscoveryPodcastFeedDTO.ListenSessionDiscoveryPodcastFeedListItem>() },
//                     BasedOnYourTaste = basedOnYourTaste ?? new DiscoveryPodcastFeedDTO.BasedOnYourTasteDiscoveryPodcastFeedSection { ShowList = new List<ShowListItemResponseDTO>() },
//                     NewReleases = newReleases ?? new DiscoveryPodcastFeedDTO.NewReleasesDiscoveryPodcastFeedSection { ShowList = new List<ShowListItemResponseDTO>() },
//                     HotThisWeek = hotThisWeek ?? new DiscoveryPodcastFeedDTO.HotThisWeekDiscoveryPodcastFeedSection { ShowList = new List<ShowListItemResponseDTO>(), ChannelList = new List<ChannelListItemResponseDTO>() },
//                     TopSubCategory = topSubCategory ?? new DiscoveryPodcastFeedDTO.TopSubCategoryDiscoveryPodcastFeedSection { ShowList = new List<ShowListItemResponseDTO>() },
//                     TopPodcasters = topPodcasters ?? new DiscoveryPodcastFeedDTO.TopPodcastersDiscoveryPodcastFeedSection { PodcasterList = new List<AccountSnippetResponseDTO>() },
//                     RandomCategory = randomCategory ?? new DiscoveryPodcastFeedDTO.RandomCategoryDiscoveryPodcastFeedSection { PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>() },
//                     TalentedRookies = talentedRookies ?? new DiscoveryPodcastFeedDTO.TalentedRookiesDiscoveryPodcastFeedSection { PodcasterList = new List<AccountSnippetResponseDTO>() }
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"\n[GetDiscoveryPodcastFeed] ERROR: {ex.Message}\n{ex.StackTrace}\n");
//                 throw new HttpRequestException("Error while getting discovery podcast feed contents: " + ex.Message);
//             }
//         }

//         #endregion

//         #region Cache Loading

//         private async Task<(
//             UserPreferencesTemporal30dQueryMetric? userPrefs,
//             SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//             CacheMetricsContainer cacheMetrics
//         )> LoadAllCacheMetricsAsync(int? userId)
//         {
//             Console.WriteLine("[LoadAllCacheMetrics] Loading all cache metrics in parallel...");

//             var tasks = new List<Task>();
//             UserPreferencesTemporal30dQueryMetric? userPrefs = null;
//             SystemPreferencesTemporal30dQueryMetric? systemPrefs = null;
//             PodcasterAllTimeMaxQueryMetric? podcasterAllTime = null;
//             PodcasterTemporal7dMaxQueryMetric? podcasterTemporal = null;
//             ShowAllTimeMaxQueryMetric? showAllTime = null;
//             ShowTemporal7dMaxQueryMetric? showTemporal = null;
//             ChannelAllTimeMaxQueryMetric? channelAllTime = null;
//             ChannelTemporal7dMaxQueryMetric? channelTemporal = null;

//             // User preferences (if logged in)
//             if (userId.HasValue)
//             {
//                 tasks.Add(Task.Run(async () =>
//                 {
//                     var cacheKey = _backgroundJobsConfig.UserPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                     var allUserPrefs = await _redisSharedCacheService
//                         .KeyGetAsync<List<UserPreferencesTemporal30dQueryMetric>>(cacheKey);
//                     userPrefs = allUserPrefs?.FirstOrDefault(up => up.UserId == userId.Value);
//                 }));
//             }

//             // System preferences
//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//                 systemPrefs = await _redisSharedCacheService
//                     .KeyGetAsync<SystemPreferencesTemporal30dQueryMetric>(cacheKey);
//             }));

//             // All-time metrics
//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 podcasterAllTime = await _redisSharedCacheService
//                     .KeyGetAsync<PodcasterAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 showAllTime = await _redisSharedCacheService
//                     .KeyGetAsync<ShowAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 channelAllTime = await _redisSharedCacheService
//                     .KeyGetAsync<ChannelAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             // Temporal 7d metrics
//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 podcasterTemporal = await _redisSharedCacheService
//                     .KeyGetAsync<PodcasterTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 showTemporal = await _redisSharedCacheService
//                     .KeyGetAsync<ShowTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 channelTemporal = await _redisSharedCacheService
//                     .KeyGetAsync<ChannelTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             await Task.WhenAll(tasks);

//             var cacheMetrics = new CacheMetricsContainer
//             {
//                 PodcasterAllTime = podcasterAllTime,
//                 PodcasterTemporal = podcasterTemporal,
//                 ShowAllTime = showAllTime,
//                 ShowTemporal = showTemporal,
//                 ChannelAllTime = channelAllTime,
//                 ChannelTemporal = channelTemporal
//             };

//             Console.WriteLine($"[LoadAllCacheMetrics] Loaded - UserPrefs: {userPrefs != null}, SystemPrefs: {systemPrefs != null}");
//             return (userPrefs, systemPrefs, cacheMetrics);
//         }

//         #endregion

//         #region Discovery Section 1: Continue Listening

//         private async Task<DiscoveryPodcastFeedDTO.ContinueListeningDiscoveryPodcastFeedSection?> BuildDiscoveryContinueListeningSection(int? userId)
//         {
//             try
//             {
//                 if (!userId.HasValue)
//                 {
//                     Console.WriteLine("[ContinueListening] Skipped - Anonymous user");
//                     return null;
//                 }

//                 Console.WriteLine($"[ContinueListening] Building for userId={userId}");

//                 var listenSessions = await _podcastEpisodeListenSessionGenericRepository.FindAll(
//                     predicate: ls =>
//                         ls.AccountId == userId.Value &&
//                         // ls.IsCompleted == false &&
//                         ls.LastListenDurationSeconds < ls.PodcastEpisode.AudioLength &&
//                         ls.IsContentRemoved == false &&
//                         ls.PodcastEpisode.DeletedAt == null &&
//                         ls.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                         (ls.PodcastEpisode.PodcastShow.PodcastChannel == null || ls.PodcastEpisode.PodcastShow.PodcastChannel.DeletedAt == null),
//                     includeFunc: q => q
//                         .Include(ls => ls.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow)
//                         .Include(ls => ls.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastEpisodeStatusTrackings)
//                         .Include(ls => ls.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ls => ls.PodcastEpisode)
//                             .ThenInclude(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastChannel)
//                             .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                         .OrderByDescending(ls => ls.CreatedAt)
//                         .Take(10)
//                 ).ToListAsync();

//                 // Filter by current status
//                 listenSessions = listenSessions.Where(ls =>
//                 {
//                     var episodeCurrentStatus = ls.PodcastEpisode.PodcastEpisodeStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastEpisodeStatusId;

//                     var showCurrentStatus = ls.PodcastEpisode.PodcastShow.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;

//                     var channelCurrentStatus = ls.PodcastEpisode.PodcastShow.PodcastChannel == null ? null : ls.PodcastEpisode.PodcastShow.PodcastChannel.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId;

//                     return episodeCurrentStatus == (int)PodcastEpisodeStatusEnum.Published &&
//                            showCurrentStatus == (int)PodcastShowStatusEnum.Published &&
//                             (channelCurrentStatus == null || channelCurrentStatus == (int)PodcastChannelStatusEnum.Published)
//                            ;
//                 }).ToList();

//                 if (!listenSessions.Any())
//                 {
//                     Console.WriteLine("[ContinueListening] No incomplete sessions found");
//                     return null;
//                 }

//                 // Get unique podcaster IDs
//                 var podcasterIds = listenSessions
//                     .Select(ls => ls.PodcastEpisode.PodcastShow.PodcasterId)
//                     .Distinct()
//                     .ToList();

//                 // Fetch all podcaster accounts
//                 var podcasterAccounts = new Dictionary<int, AccountStatusCache>();
//                 foreach (var podcasterId in podcasterIds)
//                 {
//                     var account = await _accountCachingService.GetAccountStatusCacheById(podcasterId);
//                     if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true)
//                     {
//                         podcasterAccounts[podcasterId] = account;
//                     }
//                 }

//                 var listItems = listenSessions.Select(ls =>
//                 {
//                     var podcasterId = ls.PodcastEpisode.PodcastShow.PodcasterId;
//                     var podcasterAccount = podcasterAccounts.ContainsKey(podcasterId)
//                         ? podcasterAccounts[podcasterId]
//                         : null;

//                     return new DiscoveryPodcastFeedDTO.ListenSessionDiscoveryPodcastFeedListItem
//                     {
//                         Episode = new PodcastEpisodeSnippetResponseDTO
//                         {
//                             Id = ls.PodcastEpisode.Id,
//                             Name = ls.PodcastEpisode.Name,
//                             MainImageFileKey = ls.PodcastEpisode.MainImageFileKey,
//                             IsReleased = ls.PodcastEpisode.IsReleased,
//                             ReleaseDate = ls.PodcastEpisode.ReleaseDate
//                         },
//                         Podcaster = podcasterAccount != null ? new AccountSnippetResponseDTO
//                         {
//                             Id = podcasterAccount.Id,
//                             FullName = podcasterAccount.PodcasterProfileName ?? podcasterAccount.FullName,
//                             Email = podcasterAccount.Email,
//                             MainImageFileKey = podcasterAccount.MainImageFileKey
//                         } : null,
//                         PodcastEpisodeListenSession = new PodcastEpisodeListenSessionSnippetResponseDTO
//                         {
//                             Id = ls.Id,
//                             LastListenDurationSeconds = ls.LastListenDurationSeconds
//                         }
//                     };
//                 }).ToList();

//                 Console.WriteLine($"[ContinueListening] Built with {listItems.Count} items");

//                 return new DiscoveryPodcastFeedDTO.ContinueListeningDiscoveryPodcastFeedSection
//                 {
//                     ListenSessionList = listItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[ContinueListening] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 2: Based On Your Taste

//         private async Task<DiscoveryPodcastFeedDTO.BasedOnYourTasteDiscoveryPodcastFeedSection?> BuildDiscoveryBasedOnYourTasteSection(
//     int? userId,
//     UserPreferencesTemporal30dQueryMetric? userPrefs,
//     SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//     HashSet<Guid> dedupShowIds)
//         {
//             try
//             {
//                 Console.WriteLine("[BasedOnYourTaste] Building section...");

//                 var partAShows = new List<PodcastShow>();

//                 // Part A: From user top categories (75% = 9 shows)
//                 if (userPrefs?.ListenedPodcastCategories != null && userPrefs.ListenedPodcastCategories.Any())
//                 {
//                     // var topCategories = userPrefs.ListenedPodcastCategories.Take(4).ToList();
//                     // lấy top 4 categories theo listenCount của nó
//                     var topCategories = userPrefs.ListenedPodcastCategories
//                         .OrderByDescending(c => c.ListenCount)
//                         .Take(4)
//                         .ToList();
//                     foreach (var category in topCategories)
//                     {
//                         if (partAShows.Count >= 9) break; // Đủ rồi thì dừng

//                         // Query tất cả shows trong category
//                         var shows = await _podcastShowGenericRepository.FindAll(
//                                                     predicate: ps =>
//                                                         ps.PodcastCategoryId == category.PodcastCategoryId &&
//                                                         ps.DeletedAt == null,
//                                                     includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                                                     .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                                                 ).ToListAsync();

//                         // Filter by current Published status
//                         var publishedShows = shows.Where(ps =>
//                         {
//                             var currentStatus = ps.PodcastShowStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastShowStatusId;
//                             return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                             (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                         }).ToList();

//                         // FIX: Random và take đủ số lượng cần
//                         var needed = Math.Min(3, 9 - partAShows.Count);
//                         var selectedShows = publishedShows
//                             .OrderBy(x => Guid.NewGuid())
//                             .Take(needed)
//                             .ToList();

//                         partAShows.AddRange(selectedShows);
//                     }
//                 }

//                 // Fallback Part C: System categories nếu chưa đủ 9
//                 if (partAShows.Count < 9 && systemPrefs?.ListenedPodcastCategories != null)
//                 {
//                     var existingShowIds = partAShows.Select(s => s.Id).ToHashSet();
//                     // var systemCategories = systemPrefs.ListenedPodcastCategories.Take(4).ToList();
//                     // lấy top 4 categories theo listenCount của nó
//                     var systemCategories = systemPrefs.ListenedPodcastCategories
//                         .OrderByDescending(c => c.ListenCount)
//                         .Take(4)
//                         .ToList();

//                     foreach (var category in systemCategories)
//                     {
//                         if (partAShows.Count >= 9) break;

//                         var shows = await _podcastShowGenericRepository.FindAll(
//                             predicate: ps =>
//                                 ps.PodcastCategoryId == category.PodcastCategoryId &&
//                                 !existingShowIds.Contains(ps.Id) &&
//                                 ps.DeletedAt == null,
//                             includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                             .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                         ).ToListAsync();

//                         var publishedShows = shows.Where(ps =>
//                         {
//                             var currentStatus = ps.PodcastShowStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastShowStatusId;
//                             return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                             (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                         }).ToList();

//                         var needed = Math.Min(3, 9 - partAShows.Count);
//                         var selectedShows = publishedShows
//                             .OrderBy(x => Guid.NewGuid())
//                             .Take(needed)
//                             .ToList();

//                         partAShows.AddRange(selectedShows);
//                         existingShowIds.UnionWith(selectedShows.Select(s => s.Id));
//                     }
//                 }

//                 // Part B: From user top podcasters (25% = 3 shows)
//                 var partBShows = new List<PodcastShow>();
//                 if (userPrefs?.ListenedPodcasters != null && userPrefs.ListenedPodcasters.Any())
//                 {
//                     var existingShowIds = partAShows.Select(s => s.Id).ToHashSet();
//                     // var topPodcasters = userPrefs.ListenedPodcasters.Take(2).ToList();
//                     // lấy top 2 podcasters theo listenCount của nó
//                     var topPodcasters = userPrefs.ListenedPodcasters
//                         .OrderByDescending(p => p.ListenCount)
//                         .Take(2)
//                         .ToList();

//                     foreach (var podcaster in topPodcasters)
//                     {
//                         if (partBShows.Count >= 3) break;

//                         var shows = await _podcastShowGenericRepository.FindAll(
//                             predicate: ps =>
//                                 ps.PodcasterId == podcaster.PodcasterId &&
//                                 !existingShowIds.Contains(ps.Id) &&
//                                 ps.DeletedAt == null,
//                             includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                             .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                         ).ToListAsync();

//                         var publishedShows = shows.Where(ps =>
//                         {
//                             var currentStatus = ps.PodcastShowStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastShowStatusId;
//                             return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                             (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                         }).ToList();

//                         var needed = Math.Min(2, 3 - partBShows.Count);
//                         var selectedShows = publishedShows
//                             .OrderBy(x => Guid.NewGuid())
//                             .Take(needed)
//                             .ToList();

//                         partBShows.AddRange(selectedShows);
//                         existingShowIds.UnionWith(selectedShows.Select(s => s.Id));
//                     }
//                 }

//                 // Fallback Part D: System podcasters nếu chưa đủ 3
//                 if (partBShows.Count < 3 && systemPrefs?.ListenedPodcasters != null)
//                 {
//                     var existingShowIds = partAShows.Concat(partBShows).Select(s => s.Id).ToHashSet();
//                     // var systemPodcasters = systemPrefs.ListenedPodcasters.Take(2).ToList();
//                     var systemPodcasters = systemPrefs.ListenedPodcasters
//                         .OrderByDescending(p => p.ListenCount)
//                         .Take(2)
//                         .ToList();

//                     foreach (var podcaster in systemPodcasters)
//                     {
//                         if (partBShows.Count >= 3) break;

//                         var shows = await _podcastShowGenericRepository.FindAll(
//                             predicate: ps =>
//                                 ps.PodcasterId == podcaster.PodcasterId &&
//                                 !existingShowIds.Contains(ps.Id) &&
//                                 ps.DeletedAt == null,
//                             includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                             .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                         ).ToListAsync();

//                         var publishedShows = shows.Where(ps =>
//                         {
//                             var currentStatus = ps.PodcastShowStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastShowStatusId;
//                             return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                             (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                         }).ToList();

//                         var needed = Math.Min(2, 3 - partBShows.Count);
//                         var selectedShows = publishedShows
//                             .OrderBy(x => Guid.NewGuid())
//                             .Take(needed)
//                             .ToList();

//                         partBShows.AddRange(selectedShows);
//                         existingShowIds.UnionWith(selectedShows.Select(s => s.Id));
//                     }
//                 }

//                 var finalShows = partAShows.Concat(partBShows).Take(12).ToList();

//                 // Update deduplication tracker
//                 foreach (var show in finalShows)
//                 {
//                     dedupShowIds.Add(show.Id);
//                 }

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[BasedOnYourTaste] Built with {showListItems.Count} shows (A:{partAShows.Count}, B:{partBShows.Count})");

//                 return new DiscoveryPodcastFeedDTO.BasedOnYourTasteDiscoveryPodcastFeedSection
//                 {
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[BasedOnYourTaste] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 3: New Releases

//         private async Task<DiscoveryPodcastFeedDTO.NewReleasesDiscoveryPodcastFeedSection?> BuildDiscoveryNewReleasesSection(
//     UserPreferencesTemporal30dQueryMetric? userPrefs,
//     SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//     HashSet<Guid> dedupShowIds)
//         {
//             try
//             {
//                 Console.WriteLine("[NewReleases] Building section...");

//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 var twoDaysAgo = now.AddDays(-2);

//                 var partAShows = new List<PodcastShow>();

//                 // Part A: From user top podcasters (50% = 5 shows)
//                 if (userPrefs?.ListenedPodcasters != null && userPrefs.ListenedPodcasters.Any())
//                 {
//                     var topPodcasters = userPrefs.ListenedPodcasters
//                         .OrderByDescending(p => p.ListenCount)
//                         .Take(2)
//                         .ToList();

//                     foreach (var podcaster in topPodcasters)
//                     {
//                         if (partAShows.Count >= 5) break;

//                         var shows = await _podcastShowGenericRepository.FindAll(
//                             predicate: ps =>
//                                 ps.PodcasterId == podcaster.PodcasterId &&
//                                 !dedupShowIds.Contains(ps.Id) &&
//                                 ps.DeletedAt == null,
//                             includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                             .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                         ).ToListAsync();

//                         // Filter shows that became Published in last 2 days
//                         var recentlyPublishedShows = shows.Where(ps =>
//                         {
//                             var publishedTracking = ps.PodcastShowStatusTrackings
//                                 .Where(t => t.PodcastShowStatusId == (int)PodcastShowStatusEnum.Published)
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault();

//                             return publishedTracking != null && publishedTracking.CreatedAt >= twoDaysAgo &&
//                             (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                         })
//                         .OrderByDescending(ps => ps.PodcastShowStatusTrackings
//                             .Where(t => t.PodcastShowStatusId == (int)PodcastShowStatusEnum.Published)
//                             .Max(t => t.CreatedAt))
//                         .ToList();

//                         // FIX: Take đủ số lượng cần
//                         var needed = Math.Min(recentlyPublishedShows.Count, 5 - partAShows.Count);
//                         partAShows.AddRange(recentlyPublishedShows.Take(needed));
//                     }
//                 }

//                 // Part B: System-wide new releases (bù đủ 10 total)
//                 var existingShowIds = partAShows.Select(s => s.Id).ToHashSet();
//                 existingShowIds.UnionWith(dedupShowIds);

//                 var allShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps =>
//                         !existingShowIds.Contains(ps.Id) &&
//                         ps.DeletedAt == null,
//                     includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                     .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 var partBShows = allShows.Where(ps =>
//                 {
//                     var publishedTracking = ps.PodcastShowStatusTrackings
//                         .Where(t => t.PodcastShowStatusId == (int)PodcastShowStatusEnum.Published)
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault();

//                     return publishedTracking != null && publishedTracking.CreatedAt >= twoDaysAgo &&
//                     (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 })
//                 .OrderByDescending(ps => ps.PodcastShowStatusTrackings
//                     .Where(t => t.PodcastShowStatusId == (int)PodcastShowStatusEnum.Published)
//                     .Max(t => t.CreatedAt))
//                 .Take(10 - partAShows.Count) // FIX: Bù chính xác số còn thiếu
//                 .ToList();

//                 var finalShows = partAShows.Concat(partBShows).Take(10).ToList();

//                 // Update deduplication
//                 foreach (var show in finalShows)
//                 {
//                     dedupShowIds.Add(show.Id);
//                 }

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[NewReleases] Built with {showListItems.Count} shows (A:{partAShows.Count}, B:{partBShows.Count})");

//                 return new DiscoveryPodcastFeedDTO.NewReleasesDiscoveryPodcastFeedSection
//                 {
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[NewReleases] ERROR: {ex.Message}");
//                 return null;
//             }
//         }
//         #endregion

//         #region Discovery Section 4: Hot This Week

//         private async Task<DiscoveryPodcastFeedDTO.HotThisWeekDiscoveryPodcastFeedSection?> BuildDiscoveryHotThisWeekSection(
//             CacheMetricsContainer cacheMetrics,
//             HashSet<Guid> dedupShowIds,
//             HashSet<Guid> dedupChannelIds)
//         {
//             try
//             {
//                 Console.WriteLine("[HotThisWeek] Building section...");

//                 // Fetch all shows
//                 var allShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps =>
//                         ps.DeletedAt == null &&
//                         !dedupShowIds.Contains(ps.Id),
//                     includeFunc: q => q
//                         .Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                             .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by current Published status
//                 allShows = allShows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                     (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Fetch all channels
//                 var allChannels = await _podcastChannelGenericRepository.FindAll(
//                     predicate: pc =>
//                         pc.DeletedAt == null &&
//                         !dedupChannelIds.Contains(pc.Id),
//                     includeFunc: q => q.Include(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by current Published status
//                 allChannels = allChannels.Where(pc =>
//                 {
//                     var currentStatus = pc.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId;
//                     return currentStatus == (int)PodcastChannelStatusEnum.Published;
//                 }).ToList();

//                 // Calculate hot scores (7d)
//                 var showsWithHotScore = await CalculateShowHotScoresAsync(allShows, cacheMetrics.ShowTemporal);
//                 var channelsWithHotScore = await CalculateChannelHotScoresAsync(allChannels, cacheMetrics.ChannelTemporal);

//                 // Part A (80%): 8 hot shows + 4 hot channels
//                 var partAShows = showsWithHotScore
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.show)
//                     .ToList();

//                 var partAChannels = channelsWithHotScore
//                     .OrderByDescending(x => x.score)
//                     .Take(4)
//                     .Select(x => x.channel)
//                     .ToList();

//                 // Calculate popular scores (all-time) for Part B
//                 var showsWithPopularScore = CalculateShowPopularScores(allShows, cacheMetrics.ShowAllTime);
//                 var channelsWithPopularScore = CalculateChannelPopularScores(allChannels, cacheMetrics.ChannelAllTime);

//                 var partAShowIds = partAShows.Select(s => s.Id).ToHashSet();
//                 var partAChannelIds = partAChannels.Select(c => c.Id).ToHashSet();

//                 // Part B (20%): 2 popular shows + 1 popular channel
//                 var partBShows = showsWithPopularScore
//                     .Where(x => !partAShowIds.Contains(x.show.Id))
//                     .OrderByDescending(x => x.score)
//                     .Take(2)
//                     .Select(x => x.show)
//                     .ToList();

//                 var partBChannels = channelsWithPopularScore
//                     .Where(x => !partAChannelIds.Contains(x.channel.Id))
//                     .OrderByDescending(x => x.score)
//                     .Take(1)
//                     .Select(x => x.channel)
//                     .ToList();

//                 var finalShows = partAShows.Concat(partBShows).ToList();
//                 var finalChannels = partAChannels.Concat(partBChannels).ToList();

//                 // Update deduplication
//                 foreach (var show in finalShows) dedupShowIds.Add(show.Id);
//                 foreach (var channel in finalChannels) dedupChannelIds.Add(channel.Id);

//                 var showListItems = await MapToShowListItemsAsync(finalShows);
//                 var channelListItems = await MapToChannelListItemsAsync(finalChannels);

//                 Console.WriteLine($"[HotThisWeek] Built with {showListItems.Count} shows, {channelListItems.Count} channels");

//                 return new DiscoveryPodcastFeedDTO.HotThisWeekDiscoveryPodcastFeedSection
//                 {
//                     ShowList = showListItems,
//                     ChannelList = channelListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[HotThisWeek] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 5: Top SubCategory

//         private async Task<DiscoveryPodcastFeedDTO.TopSubCategoryDiscoveryPodcastFeedSection?> BuildDiscoveryTopSubCategorySection(
//             int? userId,
//             UserPreferencesTemporal30dQueryMetric? userPrefs,
//             SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//             CacheMetricsContainer cacheMetrics,
//             HashSet<Guid> dedupShowIds)
//         {
//             try
//             {
//                 Console.WriteLine("[TopSubCategory] Building section...");

//                 // Determine top subcategory
//                 int? targetSubCategoryId = null;
//                 int? targetCategoryId = null;

//                 if (userPrefs?.ListenedPodcastCategories != null && userPrefs.ListenedPodcastCategories.Any())
//                 {
//                     // var topCategory = userPrefs.ListenedPodcastCategories.First();
//                     // lấy top category theo listenCount của nó
//                     var topCategory = userPrefs.ListenedPodcastCategories
//                         .OrderByDescending(c => c.ListenCount)
//                         .First();
//                     targetCategoryId = topCategory.PodcastCategoryId;
//                     if (topCategory.PodcastSubCategories != null && topCategory.PodcastSubCategories.Any())
//                     {
//                         targetSubCategoryId = topCategory.PodcastSubCategories.First().PodcastSubCategoryId;
//                     }
//                 }

//                 // Fallback to system
//                 if (!targetSubCategoryId.HasValue && systemPrefs?.ListenedPodcastCategories != null && systemPrefs.ListenedPodcastCategories.Any())
//                 {
//                     // var topCategory = systemPrefs.ListenedPodcastCategories.First();
//                     // lấy top category theo listenCount của nó
//                     var topCategory = systemPrefs.ListenedPodcastCategories
//                         .OrderByDescending(c => c.ListenCount)
//                         .First();
//                     targetCategoryId = topCategory.PodcastCategoryId;
//                     if (topCategory.PodcastSubCategories != null && topCategory.PodcastSubCategories.Any())
//                     {
//                         targetSubCategoryId = topCategory.PodcastSubCategories.First().PodcastSubCategoryId;
//                     }
//                 }

//                 if (!targetSubCategoryId.HasValue)
//                 {
//                     Console.WriteLine("[TopSubCategory] No subcategory found");
//                     return null;
//                 }

//                 // Fetch subcategory entity
//                 var subCategory = await _podcastSubCategoryGenericRepository.FindAll(
//                     predicate: psc => psc.Id == targetSubCategoryId.Value,
//                     includeFunc: q => q.Include(psc => psc.PodcastCategory)
//                 ).FirstOrDefaultAsync();

//                 if (subCategory == null)
//                 {
//                     Console.WriteLine("[TopSubCategory] Subcategory not found in DB");
//                     return null;
//                 }

//                 // Fetch shows in subcategory
//                 var shows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps =>
//                         ps.PodcastSubCategoryId == targetSubCategoryId.Value &&
//                         !dedupShowIds.Contains(ps.Id) &&
//                         ps.DeletedAt == null,
//                     includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by current Published status
//                 shows = shows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                     (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Part A (80%): 8 personal shows
//                 var showsWithPersonalScore = userId.HasValue
//                     ? await CalculatePersonalShowScoresAsync(shows, userId.Value)
//                     : shows.Select(s => (show: s, score: 0.0)).ToList();

//                 var partAShows = showsWithPersonalScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.show)
//                     .ToList();

//                 // Part B (20%): Popular shows to fill deficit
//                 var needed = 8 - partAShows.Count;
//                 var partBShows = new List<PodcastShow>();

//                 if (needed > 0)
//                 {
//                     var existingIds = partAShows.Select(s => s.Id).ToHashSet();
//                     var showsWithPopularScore = CalculateShowPopularScores(
//                         shows.Where(s => !existingIds.Contains(s.Id)).ToList(),
//                         cacheMetrics.ShowAllTime
//                     );

//                     partBShows = showsWithPopularScore
//                         .OrderByDescending(x => x.score)
//                         .Take(2 + needed)
//                         .Select(x => x.show)
//                         .ToList();
//                 }

//                 var finalShows = partAShows.Concat(partBShows.Take(2 + needed)).Take(10).ToList();

//                 // Update deduplication
//                 foreach (var show in finalShows) dedupShowIds.Add(show.Id);

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 var subCategoryDTO = new PodcastSubCategoryListItemResponseDTO
//                 {
//                     Id = subCategory.Id,
//                     Name = subCategory.Name,
//                     PodcastCategoryId = subCategory.PodcastCategoryId,
//                     PodcastCategory = new PodcastCategoryDTO
//                     {
//                         Id = subCategory.PodcastCategory.Id,
//                         Name = subCategory.PodcastCategory.Name,
//                     }
//                 };

//                 Console.WriteLine($"[TopSubCategory] Built with {showListItems.Count} shows for subcategory {targetSubCategoryId}");

//                 return new DiscoveryPodcastFeedDTO.TopSubCategoryDiscoveryPodcastFeedSection
//                 {
//                     PodcastSubCategory = subCategoryDTO,
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TopSubCategory] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 6: Top Podcasters

//         private async Task<DiscoveryPodcastFeedDTO.TopPodcastersDiscoveryPodcastFeedSection?> BuildDiscoveryTopPodcastersSection(
//             CacheMetricsContainer cacheMetrics,
//             HashSet<int> dedupPodcasterIds)
//         {
//             try
//             {
//                 Console.WriteLine("[TopPodcasters] Building section...");

//                 // Fetch all verified podcasters from UserService
//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                     {
//                         new BatchQueryItem
//                         {
//                             Key = "verifiedPodcasters",
//                             QueryType = "findall",
//                             EntityType = "PodcasterProfile",
//                             Parameters = JObject.FromObject(new { IsVerified = true })
//                         }
//                     }
//                 };

//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var allPodcasters = result.Results["verifiedPodcasters"].ToObject<List<PodcasterProfileDTO>>();

//                 // Filter out already used podcasters
//                 allPodcasters = allPodcasters.Where(p => !dedupPodcasterIds.Contains(p.AccountId)).ToList();

//                 // Calculate hot scores (7d)
//                 var podcastersWithHotScore = await CalculatePodcasterHotScoresAsync(allPodcasters, cacheMetrics.PodcasterTemporal);

//                 // Part A (20%): 4 hot podcasters
//                 var partAPodcasters = podcastersWithHotScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(4)
//                     .Select(x => x.podcaster)
//                     .ToList();

//                 // Calculate popular scores (all-time)
//                 var podcastersWithPopularScore = CalculatePodcasterPopularScores(allPodcasters, cacheMetrics.PodcasterAllTime);

//                 var partAPodcasterIds = partAPodcasters.Select(p => p.AccountId).ToHashSet();

//                 // Part B (80%): 8 popular podcasters
//                 var partBPodcasters = podcastersWithPopularScore
//                     .Where(x => !partAPodcasterIds.Contains(x.podcaster.AccountId))
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.podcaster)
//                     .ToList();

//                 var finalPodcasters = partAPodcasters.Concat(partBPodcasters).Take(12).ToList();

//                 // Update deduplication
//                 foreach (var podcaster in finalPodcasters)
//                 {
//                     dedupPodcasterIds.Add(podcaster.AccountId);
//                 }

//                 // Fetch full account details
//                 var podcasterListItems = new List<AccountSnippetResponseDTO>();
//                 foreach (var podcaster in finalPodcasters)
//                 {
//                     var account = await _accountCachingService.GetAccountStatusCacheById(podcaster.AccountId);
//                     if (account != null)
//                     {
//                         podcasterListItems.Add(new AccountSnippetResponseDTO
//                         {
//                             Id = account.Id,
//                             FullName = account.PodcasterProfileName ?? account.FullName,
//                             Email = account.Email,
//                             MainImageFileKey = account.MainImageFileKey
//                         });
//                     }
//                 }

//                 Console.WriteLine($"[TopPodcasters] Built with {podcasterListItems.Count} podcasters");

//                 return new DiscoveryPodcastFeedDTO.TopPodcastersDiscoveryPodcastFeedSection
//                 {
//                     PodcasterList = podcasterListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TopPodcasters] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 7: Random Category

//         private async Task<DiscoveryPodcastFeedDTO.RandomCategoryDiscoveryPodcastFeedSection?> BuildDiscoveryRandomCategorySection(
//             UserPreferencesTemporal30dQueryMetric? userPrefs,
//             SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//             CacheMetricsContainer cacheMetrics,
//             HashSet<Guid> dedupShowIds)
//         {
//             try
//             {
//                 Console.WriteLine("[RandomCategory] Building section...");

//                 // Get top 2 categories to exclude
//                 var excludeCategoryIds = new HashSet<int>();
//                 if (userPrefs?.ListenedPodcastCategories != null && userPrefs.ListenedPodcastCategories.Any())
//                 {
//                     excludeCategoryIds = userPrefs.ListenedPodcastCategories
//                         .OrderByDescending(c => c.ListenCount)
//                         .Take(2)
//                         .Select(c => c.PodcastCategoryId)
//                         .ToHashSet();
//                 }

//                 // Fetch all category IDs from database
//                 var allCategoryIds = await _podcastCategoryGenericRepository.FindAll()
//                     .Select(pc => pc.Id)
//                     .ToListAsync();

//                 var availableCategoryIds = allCategoryIds
//                     .Where(id => !excludeCategoryIds.Contains(id))
//                     .ToList();

//                 if (!availableCategoryIds.Any())
//                 {
//                     Console.WriteLine("[RandomCategory] No available categories");
//                     return null;
//                 }

//                 // availableCategoryIds.ForEach(id => Console.WriteLine($"[RandomCategory] Available category: {id}"));

//                 // Pick random category
//                 var random = new Random();
//                 var randomCategoryId = availableCategoryIds[random.Next(availableCategoryIds.Count)];
//                 var randomCategory = await _podcastCategoryGenericRepository.FindByIdAsync(randomCategoryId);

//                 Console.WriteLine($"[RandomCategory] Selected category: {randomCategoryId}");

//                 // Fetch shows in category
//                 var shows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps =>
//                         ps.PodcastCategoryId == randomCategoryId &&
//                         !dedupShowIds.Contains(ps.Id) &&
//                         ps.DeletedAt == null,
//                     includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by current Published status
//                 shows = shows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                     (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Part A (30%): 3 hot shows
//                 var showsWithHotScore = await CalculateShowHotScoresAsync(shows, cacheMetrics.ShowTemporal);

//                 var partAShows = showsWithHotScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(3)
//                     .Select(x => x.show)
//                     .ToList();

//                 // Part B (70%): 9 popular shows
//                 var existingIds = partAShows.Select(s => s.Id).ToHashSet();
//                 var showsWithPopularScore = CalculateShowPopularScores(
//                     shows.Where(s => !existingIds.Contains(s.Id)).ToList(),
//                     cacheMetrics.ShowAllTime
//                 );

//                 var needed = 3 - partAShows.Count;
//                 var partBShows = showsWithPopularScore
//                     .OrderByDescending(x => x.score)
//                     .Take(9 + needed)
//                     .Select(x => x.show)
//                     .ToList();

//                 var finalShows = partAShows.Concat(partBShows).Take(12).ToList();

//                 // Update deduplication
//                 foreach (var show in finalShows) dedupShowIds.Add(show.Id);

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[RandomCategory] Built with {showListItems.Count} shows");

//                 return new DiscoveryPodcastFeedDTO.RandomCategoryDiscoveryPodcastFeedSection
//                 {
//                     PodcastCategory = new PodcastCategoryDTO
//                     {
//                         Id = randomCategory.Id,
//                         Name = randomCategory.Name
//                     },
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[RandomCategory] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Discovery Section 8: Talented Rookies

//         private async Task<DiscoveryPodcastFeedDTO.TalentedRookiesDiscoveryPodcastFeedSection?> BuildDiscoveryTalentedRookiesSection(
//             CacheMetricsContainer cacheMetrics,
//             HashSet<int> dedupPodcasterIds)
//         {
//             try
//             {
//                 Console.WriteLine("[TalentedRookies] Building section...");

//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 var ninetyDaysAgo = now.AddDays(-90);

//                 // Fetch all verified podcasters from UserService
//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//                     {
//                         new BatchQueryItem
//                         {
//                             Key = "rookiePodcasters",
//                             QueryType = "findall",
//                             EntityType = "PodcasterProfile",
//                             Parameters = JObject.FromObject(new { IsVerified = true })
//                         }
//                     }
//                 };

//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var allPodcasters = result.Results["rookiePodcasters"].ToObject<List<PodcasterProfileDTO>>();

//                 // Filter rookies (verified ≤ 90 days and not already used)
//                 var rookies = allPodcasters
//                     .Where(p => p.VerifiedAt.HasValue && p.VerifiedAt.Value >= ninetyDaysAgo)
//                     .Where(p => !dedupPodcasterIds.Contains(p.AccountId))
//                     .ToList();

//                 // Calculate rookie scores
//                 var rookiesWithScore = CalculateRookieScores(rookies, cacheMetrics.PodcasterAllTime);

//                 var finalRookies = rookiesWithScore
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.podcaster)
//                     .ToList();

//                 // Update deduplication
//                 foreach (var rookie in finalRookies)
//                 {
//                     dedupPodcasterIds.Add(rookie.AccountId);
//                 }

//                 // Fetch full account details
//                 var rookieListItems = new List<AccountSnippetResponseDTO>();
//                 foreach (var rookie in finalRookies)
//                 {
//                     var account = await _accountCachingService.GetAccountStatusCacheById(rookie.AccountId);
//                     if (account != null)
//                     {
//                         rookieListItems.Add(new AccountSnippetResponseDTO
//                         {
//                             Id = account.Id,
//                             FullName = account.PodcasterProfileName ?? account.FullName,
//                             Email = account.Email,
//                             MainImageFileKey = account.MainImageFileKey
//                         });
//                     }
//                 }

//                 Console.WriteLine($"[TalentedRookies] Built with {rookieListItems.Count} rookies");

//                 return new DiscoveryPodcastFeedDTO.TalentedRookiesDiscoveryPodcastFeedSection
//                 {
//                     PodcasterList = rookieListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TalentedRookies] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Score Calculation Helpers

//         // ============ SHOW SCORES ============
//         private async Task<List<(PodcastShow show, double score)>> CalculateShowHotScoresAsync(
//     List<PodcastShow> shows,
//     ShowTemporal7dMaxQueryMetric? temporal7dMetric)
//         {
//             if (temporal7dMetric == null || temporal7dMetric.MaxNewListenSession == 0)
//                 return shows.Select(s => (s, 0.0)).ToList();

//             var now = _dateHelper.GetNowByAppTimeZone();
//             var sevenDaysAgo = now.AddDays(-7);

//             // Query listen sessions (7 days)
//             var showIds = shows.Select(s => s.Id).ToList();
//             var listenSessions = await _podcastEpisodeListenSessionGenericRepository.FindAll(
//                 predicate: ls =>
//                     ls.CreatedAt >= sevenDaysAgo &&
//                     ls.IsContentRemoved == false &&
//                     ls.PodcastEpisode.DeletedAt == null && // FIX: Add episode check
//                     ls.PodcastEpisode.PodcastShow.DeletedAt == null && // FIX: Add show check
//                     showIds.Contains(ls.PodcastEpisode.PodcastShowId),
//                 includeFunc: q => q
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastEpisodeStatusTrackings)
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastShow)
//             ).ToListAsync();

//             // FIX: Filter by Published status
//             listenSessions = listenSessions.Where(ls =>
//             {
//                 var episodeStatus = ls.PodcastEpisode.PodcastEpisodeStatusTrackings
//                     .OrderByDescending(t => t.CreatedAt)
//                     .FirstOrDefault()?.PodcastEpisodeStatusId;
//                 return episodeStatus == (int)PodcastEpisodeStatusEnum.Published;
//             }).ToList();

//             var listenSessionsByShow = listenSessions
//                 .GroupBy(ls => ls.PodcastEpisode.PodcastShowId)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Query follows (7 days) from UserService
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "recentFollows",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcastShow",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };
//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["recentFollows"].ToObject<List<AccountFollowedPodcastShowDTO>>();

//             var recentFollows = allFollows
//                 .Where(f => f.CreatedAt >= sevenDaysAgo && showIds.Contains(f.PodcastShowId))
//                 .GroupBy(f => f.PodcastShowId)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Calculate scores
//             var results = new List<(PodcastShow show, double score)>();
//             foreach (var show in shows)
//             {
//                 var nls = listenSessionsByShow.ContainsKey(show.Id) ? listenSessionsByShow[show.Id] : 0;
//                 var nf = recentFollows.ContainsKey(show.Id) ? recentFollows[show.Id] : 0;

//                 var normalizedNLS = temporal7dMetric.MaxNewListenSession > 0
//                     ? (double)nls / temporal7dMetric.MaxNewListenSession
//                     : 0;
//                 var normalizedNF = temporal7dMetric.MaxNewFollow > 0
//                     ? (double)nf / temporal7dMetric.MaxNewFollow
//                     : 0;

//                 var hotScore = 0.6 * normalizedNLS + 0.4 * normalizedNF;
//                 results.Add((show, hotScore));
//             }

//             return results;
//         }

//         private List<(PodcastShow show, double score)> CalculateShowPopularScores(
//             List<PodcastShow> shows,
//             ShowAllTimeMaxQueryMetric? allTimeMetric)
//         {
//             if (allTimeMetric == null)
//                 return shows.Select(s => (s, 0.0)).ToList();

//             var results = new List<(PodcastShow show, double score)>();
//             foreach (var show in shows)
//             {
//                 var normalizedTF = allTimeMetric.MaxTotalFollow > 0
//                     ? (double)show.TotalFollow / allTimeMetric.MaxTotalFollow
//                     : 0;
//                 var normalizedLC = allTimeMetric.MaxListenCount > 0
//                     ? (double)show.ListenCount / allTimeMetric.MaxListenCount
//                     : 0;

//                 var rt = show.AverageRating * Math.Log(show.RatingCount + 1);
//                 var normalizedRT = allTimeMetric.MaxRatingTerm > 0
//                     ? rt / allTimeMetric.MaxRatingTerm
//                     : 0;

//                 var popularScore = 0.4 * normalizedTF + 0.4 * normalizedLC + 0.2 * normalizedRT;
//                 results.Add((show, popularScore));
//             }

//             return results;
//         }

//         // ============ CHANNEL SCORES ============
//         private async Task<List<(PodcastChannel channel, double score)>> CalculateChannelHotScoresAsync(
//     List<PodcastChannel> channels,
//     ChannelTemporal7dMaxQueryMetric? temporal7dMetric)
//         {
//             if (temporal7dMetric == null || temporal7dMetric.MaxNewListenSession == 0)
//                 return channels.Select(c => (c, 0.0)).ToList();

//             var now = _dateHelper.GetNowByAppTimeZone();
//             var sevenDaysAgo = now.AddDays(-7);

//             // Query listen sessions (7 days)
//             var channelIds = channels.Select(c => c.Id).ToList();
//             var listenSessions = await _podcastEpisodeListenSessionGenericRepository.FindAll(
//                 predicate: ls =>
//                     ls.CreatedAt >= sevenDaysAgo &&
//                     ls.IsContentRemoved == false &&
//                     ls.PodcastEpisode.DeletedAt == null && // FIX: Add checks
//                     ls.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                     ls.PodcastEpisode.PodcastShow.PodcastChannelId != null &&
//                     channelIds.Contains(ls.PodcastEpisode.PodcastShow.PodcastChannelId.Value),
//                 includeFunc: q => q
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastEpisodeStatusTrackings)
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastShow)
//             ).ToListAsync();

//             // FIX: Filter by Published status
//             listenSessions = listenSessions.Where(ls =>
//             {
//                 var episodeStatus = ls.PodcastEpisode.PodcastEpisodeStatusTrackings
//                     .OrderByDescending(t => t.CreatedAt)
//                     .FirstOrDefault()?.PodcastEpisodeStatusId;
//                 return episodeStatus == (int)PodcastEpisodeStatusEnum.Published;
//             }).ToList();

//             var listenSessionsByChannel = listenSessions
//                 .GroupBy(ls => ls.PodcastEpisode.PodcastShow.PodcastChannelId.Value)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Query favorites from UserService
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "recentFavorites",
//                 QueryType = "findall",
//                 EntityType = "AccountFavoritedPodcastChannel",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };
//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFavorites = result.Results["recentFavorites"].ToObject<List<AccountFavoritedPodcastChannelDTO>>();

//             var recentFavorites = allFavorites
//                 .Where(f => f.CreatedAt >= sevenDaysAgo && channelIds.Contains(f.PodcastChannelId))
//                 .GroupBy(f => f.PodcastChannelId)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Calculate scores
//             var results = new List<(PodcastChannel channel, double score)>();
//             foreach (var channel in channels)
//             {
//                 var nls = listenSessionsByChannel.ContainsKey(channel.Id) ? listenSessionsByChannel[channel.Id] : 0;
//                 var nf = recentFavorites.ContainsKey(channel.Id) ? recentFavorites[channel.Id] : 0;

//                 var normalizedNLS = temporal7dMetric.MaxNewListenSession > 0
//                     ? (double)nls / temporal7dMetric.MaxNewListenSession
//                     : 0;
//                 var normalizedNF = temporal7dMetric.MaxNewFavorite > 0
//                     ? (double)nf / temporal7dMetric.MaxNewFavorite
//                     : 0;

//                 var hotScore = 0.6 * normalizedNLS + 0.4 * normalizedNF;
//                 results.Add((channel, hotScore));
//             }

//             return results;
//         }

//         private List<(PodcastChannel channel, double score)> CalculateChannelPopularScores(
//             List<PodcastChannel> channels,
//             ChannelAllTimeMaxQueryMetric? allTimeMetric)
//         {
//             if (allTimeMetric == null)
//                 return channels.Select(c => (c, 0.0)).ToList();

//             var results = new List<(PodcastChannel channel, double score)>();
//             foreach (var channel in channels)
//             {
//                 var normalizedLC = allTimeMetric.MaxListenCount > 0
//                     ? (double)channel.ListenCount / allTimeMetric.MaxListenCount
//                     : 0;
//                 var normalizedTF = allTimeMetric.MaxTotalFavorite > 0
//                     ? (double)channel.TotalFavorite / allTimeMetric.MaxTotalFavorite
//                     : 0;

//                 var popularScore = 0.6 * normalizedLC + 0.4 * normalizedTF;
//                 results.Add((channel, popularScore));
//             }

//             return results;
//         }

//         // ============ PODCASTER SCORES ============
//         private async Task<List<(PodcasterProfileDTO podcaster, double score)>> CalculatePodcasterHotScoresAsync(
//     List<PodcasterProfileDTO> podcasters,
//     PodcasterTemporal7dMaxQueryMetric? temporal7dMetric)
//         {
//             if (temporal7dMetric == null || temporal7dMetric.MaxNewListenSession == 0)
//                 return podcasters.Select(p => (p, 0.0)).ToList();

//             var now = _dateHelper.GetNowByAppTimeZone();
//             var sevenDaysAgo = now.AddDays(-7);

//             // FIX: Filter podcasters với DeactivatedAt từ cache
//             var validPodcasterIds = new HashSet<int>();
//             foreach (var podcaster in podcasters)
//             {
//                 var account = await _accountCachingService.GetAccountStatusCacheById(podcaster.AccountId);
//                 if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true)
//                 {
//                     validPodcasterIds.Add(podcaster.AccountId);
//                 }
//             }

//             // Query listen sessions (7 days)
//             var listenSessions = await _podcastEpisodeListenSessionGenericRepository.FindAll(
//                 predicate: ls =>
//                     ls.CreatedAt >= sevenDaysAgo &&
//                     ls.IsContentRemoved == false &&
//                     ls.PodcastEpisode.DeletedAt == null &&
//                     ls.PodcastEpisode.PodcastShow.DeletedAt == null &&
//                     validPodcasterIds.Contains(ls.PodcastEpisode.PodcastShow.PodcasterId),
//                 includeFunc: q => q
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastEpisodeStatusTrackings)
//                     .Include(ls => ls.PodcastEpisode)
//                         .ThenInclude(pe => pe.PodcastShow)
//             ).ToListAsync();

//             // FIX: Filter by Published status
//             listenSessions = listenSessions.Where(ls =>
//             {
//                 var episodeStatus = ls.PodcastEpisode.PodcastEpisodeStatusTrackings
//                     .OrderByDescending(t => t.CreatedAt)
//                     .FirstOrDefault()?.PodcastEpisodeStatusId;
//                 return episodeStatus == (int)PodcastEpisodeStatusEnum.Published;
//             }).ToList();

//             var listenSessionsByPodcaster = listenSessions
//                 .GroupBy(ls => ls.PodcastEpisode.PodcastShow.PodcasterId)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Query follows from UserService
//             var batchRequest = new BatchQueryRequest
//             {
//                 Queries = new List<BatchQueryItem>
//         {
//             new BatchQueryItem
//             {
//                 Key = "recentFollows",
//                 QueryType = "findall",
//                 EntityType = "AccountFollowedPodcaster",
//                 Parameters = JObject.FromObject(new { })
//             }
//         }
//             };
//             var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//             var allFollows = result.Results["recentFollows"].ToObject<List<AccountFollowedPodcasterDTO>>();

//             var recentFollows = allFollows
//                 .Where(f => f.CreatedAt >= sevenDaysAgo && validPodcasterIds.Contains(f.PodcasterId))
//                 .GroupBy(f => f.PodcasterId)
//                 .ToDictionary(g => g.Key, g => g.Count());

//             // Calculate scores - chỉ cho valid podcasters
//             var results = new List<(PodcasterProfileDTO podcaster, double score)>();
//             foreach (var podcaster in podcasters.Where(p => validPodcasterIds.Contains(p.AccountId)))
//             {
//                 var nls = listenSessionsByPodcaster.ContainsKey(podcaster.AccountId)
//                     ? listenSessionsByPodcaster[podcaster.AccountId] : 0;
//                 var nf = recentFollows.ContainsKey(podcaster.AccountId)
//                     ? recentFollows[podcaster.AccountId] : 0;

//                 var g = nls + nf;

//                 var normalizedNLS = temporal7dMetric.MaxNewListenSession > 0
//                     ? (double)nls / temporal7dMetric.MaxNewListenSession
//                     : 0;
//                 var normalizedNF = temporal7dMetric.MaxNewFollow > 0
//                     ? (double)nf / temporal7dMetric.MaxNewFollow
//                     : 0;
//                 var normalizedG = temporal7dMetric.MaxGrowth > 0
//                     ? (double)g / (2 * temporal7dMetric.MaxGrowth)
//                     : 0;
//                 var normalizedRating = podcaster.AverageRating / 5.0;

//                 var hotScore = 0.5 * normalizedNLS + 0.3 * normalizedNF + 0.15 * normalizedG + 0.05 * normalizedRating;
//                 results.Add((podcaster, hotScore));
//             }

//             return results;
//         }

//         private List<(PodcasterProfileDTO podcaster, double score)> CalculatePodcasterPopularScores(
//             List<PodcasterProfileDTO> podcasters,
//             PodcasterAllTimeMaxQueryMetric? allTimeMetric)
//         {
//             if (allTimeMetric == null)
//                 return podcasters.Select(p => (p, 0.0)).ToList();

//             var now = _dateHelper.GetNowByAppTimeZone();
//             var results = new List<(PodcasterProfileDTO podcaster, double score)>();

//             foreach (var podcaster in podcasters)
//             {
//                 var normalizedTF = allTimeMetric.MaxTotalFollow > 0
//                     ? (double)podcaster.TotalFollow / allTimeMetric.MaxTotalFollow
//                     : 0;
//                 var normalizedLC = allTimeMetric.MaxListenCount > 0
//                     ? (double)podcaster.ListenCount / allTimeMetric.MaxListenCount
//                     : 0;

//                 var rt = podcaster.AverageRating * Math.Log(podcaster.RatingCount + 1);
//                 var normalizedRT = allTimeMetric.MaxRatingTerm > 0
//                     ? rt / allTimeMetric.MaxRatingTerm
//                     : 0;

//                 var age = podcaster.VerifiedAt.HasValue
//                     ? (now - podcaster.VerifiedAt.Value).TotalDays
//                     : 0;
//                 var normalizedAge = allTimeMetric.MaxAge > 0
//                     ? age / allTimeMetric.MaxAge
//                     : 0;

//                 var popularScore = 0.4 * normalizedTF + 0.4 * normalizedLC + 0.15 * normalizedRT + 0.05 * normalizedAge;
//                 results.Add((podcaster, popularScore));
//             }

//             return results;
//         }

//         private List<(PodcasterProfileDTO podcaster, double score)> CalculateRookieScores(
//             List<PodcasterProfileDTO> podcasters,
//             PodcasterAllTimeMaxQueryMetric? allTimeMetric)
//         {
//             if (allTimeMetric == null)
//                 return podcasters.Select(p => (p, 0.0)).ToList();

//             var now = _dateHelper.GetNowByAppTimeZone();
//             var results = new List<(PodcasterProfileDTO podcaster, double score)>();

//             foreach (var podcaster in podcasters)
//             {
//                 var normalizedLC = allTimeMetric.MaxListenCount > 0
//                     ? (double)podcaster.ListenCount / allTimeMetric.MaxListenCount
//                     : 0;

//                 var ageInDays = podcaster.VerifiedAt.HasValue
//                     ? Math.Max(1, (now - podcaster.VerifiedAt.Value).TotalDays)
//                     : 1;
//                 var growth = podcaster.TotalFollow / ageInDays;

//                 // Calculate MaxGrowth dynamically if not in cache
//                 var maxGrowth = allTimeMetric.MaxAge > 0
//                     ? (double)allTimeMetric.MaxTotalFollow / allTimeMetric.MaxAge
//                     : 1;
//                 var normalizedG = maxGrowth > 0
//                     ? growth / maxGrowth
//                     : 0;

//                 var rt = podcaster.AverageRating * Math.Log(podcaster.RatingCount + 1);
//                 var normalizedRT = allTimeMetric.MaxRatingTerm > 0
//                     ? rt / allTimeMetric.MaxRatingTerm
//                     : 0;

//                 var rookieScore = 0.4 * normalizedLC + 0.4 * normalizedG + 0.2 * normalizedRT;
//                 results.Add((podcaster, rookieScore));
//             }

//             return results;
//         }

//         private async Task<List<(PodcastShow show, double score)>> CalculatePersonalShowScoresAsync(
//             List<PodcastShow> shows,
//             int userId)
//         {
//             var result = new List<(PodcastShow show, double score)>();

//             foreach (var show in shows)
//             {
//                 // Calculate user engagement
//                 var totalEpisodes = await _podcastEpisodeGenericRepository.FindAll(
//                     predicate: pe =>
//                         pe.PodcastShowId == show.Id &&
//                         pe.DeletedAt == null,
//                     includeFunc: q => q.Include(pe => pe.PodcastEpisodeStatusTrackings)
//                 ).CountAsync(pe => pe.PodcastEpisodeStatusTrackings
//                     .OrderByDescending(t => t.CreatedAt)
//                     .FirstOrDefault().PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published);

//                 var listenedEpisodeIds = await _podcastEpisodeListenSessionGenericRepository.FindAll(
//                     predicate: ls =>
//                         ls.AccountId == userId &&
//                         ls.PodcastEpisode.PodcastShowId == show.Id,
//                     includeFunc: q => q.Include(ls => ls.PodcastEpisode)
//                 ).Select(ls => ls.PodcastEpisodeId).Distinct().CountAsync();

//                 var userEngagement = totalEpisodes > 0 ? (double)listenedEpisodeIds / totalEpisodes : 0;

//                 // Calculate show quality
//                 var normalizedTF = Math.Min(show.TotalFollow, 100000) / 100000.0;
//                 var normalizedRating = show.AverageRating / 5.0;
//                 var showQuality = 0.5 * normalizedTF + 0.5 * normalizedRating;

//                 var personalScore = 0.6 * userEngagement + 0.4 * showQuality;

//                 result.Add((show, personalScore));
//             }

//             return result;
//         }

//         #endregion

//         #region Mapping Helpers

//         private async Task<List<ShowListItemResponseDTO>> MapToShowListItemsAsync(List<PodcastShow> shows)
//         {
//             var result = new List<ShowListItemResponseDTO>();

//             // Collect unique IDs
//             var podcasterIds = shows.Select(s => s.PodcasterId).Distinct().ToList();
//             var channelIds = shows.Where(s => s.PodcastChannelId.HasValue).Select(s => s.PodcastChannelId.Value).Distinct().ToList();
//             var categoryIds = shows.Where(s => s.PodcastCategoryId.HasValue).Select(s => s.PodcastCategoryId.Value).Distinct().ToList();
//             var subCategoryIds = shows.Where(s => s.PodcastSubCategoryId.HasValue).Select(s => s.PodcastSubCategoryId.Value).Distinct().ToList();

//             // Batch fetch podcasters
//             var podcasterAccounts = new Dictionary<int, AccountStatusCache>();
//             foreach (var id in podcasterIds)
//             {
//                 var account = await _accountCachingService.GetAccountStatusCacheById(id);
//                 if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true) // FIX: Check DeactivatedAt
//                 {
//                     podcasterAccounts[id] = account;
//                 }
//             }

//             // Fetch categories
//             var categories = await _podcastCategoryGenericRepository.FindAll(
//                 predicate: pc => categoryIds.Contains(pc.Id)
//             ).ToDictionaryAsync(pc => pc.Id, pc => pc);

//             // Fetch subcategories
//             var subCategories = await _podcastSubCategoryGenericRepository.FindAll(
//                 predicate: psc => subCategoryIds.Contains(psc.Id)
//             ).ToDictionaryAsync(psc => psc.Id, psc => psc);

//             // Fetch channels
//             var channels = await _podcastChannelGenericRepository.FindAll(
//                 predicate: pc => channelIds.Contains(pc.Id),
//                 includeFunc: q => q.Include(pc => pc.PodcastChannelStatusTrackings)
//             ).ToDictionaryAsync(pc => pc.Id, pc => pc);

//             // Fetch hashtags
//             var showHashtags = await _podcastShowHashtagGenericRepository.FindAll(
//                 predicate: psh => shows.Select(s => s.Id).Contains(psh.PodcastShowId),
//                 includeFunc: q => q.Include(psh => psh.Hashtag)
//             ).ToListAsync();

//             var hashtagsByShow = showHashtags
//                 .GroupBy(psh => psh.PodcastShowId)
//                 .ToDictionary(g => g.Key, g => g.Select(psh => psh.Hashtag).ToList());

//             // Fetch subscription types
//             var subscriptionTypes = await _appDbContext.PodcastShowSubscriptionTypes
//                 .ToDictionaryAsync(psst => psst.Id, psst => psst);

//             // Fetch episodes count for each show
//             var episodeCounts = await _podcastEpisodeGenericRepository.FindAll(
//                 predicate: pe =>
//                     shows.Select(s => s.Id).Contains(pe.PodcastShowId) &&
//                     pe.DeletedAt == null,
//                 includeFunc: q => q.Include(pe => pe.PodcastEpisodeStatusTrackings)
//             )
//             .ToListAsync()
//             .ContinueWith(task =>
//             {
//                 return task.Result
//                     .Where(pe => pe.PodcastEpisodeStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published)
//                     .GroupBy(pe => pe.PodcastShowId)
//                     .ToDictionary(g => g.Key, g => g.Count());
//             });

//             // Map each show
//             foreach (var show in shows)
//             {
//                 var podcasterAccount = podcasterAccounts.ContainsKey(show.PodcasterId)
//                     ? podcasterAccounts[show.PodcasterId]
//                     : null;

//                 var currentStatus = show.PodcastShowStatusTrackings
//                     .OrderByDescending(pst => pst.CreatedAt)
//                     .FirstOrDefault();

//                 var item = new ShowListItemResponseDTO
//                 {
//                     Id = show.Id,
//                     Name = show.Name,
//                     Description = show.Description,
//                     Language = show.Language,
//                     ReleaseDate = show.ReleaseDate,
//                     IsReleased = show.IsReleased,
//                     Copyright = show.Copyright,
//                     UploadFrequency = show.UploadFrequency,
//                     RatingCount = show.RatingCount,
//                     AverageRating = show.AverageRating,
//                     MainImageFileKey = show.MainImageFileKey,
//                     TrailerAudioFileKey = show.TrailerAudioFileKey,
//                     ListenCount = show.ListenCount,
//                     TotalFollow = show.TotalFollow,
//                     EpisodeCount = episodeCounts.ContainsKey(show.Id) ? episodeCounts[show.Id] : 0,
//                     TakenDownReason = show.TakenDownReason,
//                     CreatedAt = show.CreatedAt,
//                     UpdatedAt = show.UpdatedAt,

//                     Podcaster = podcasterAccount != null ? new AccountSnippetResponseDTO
//                     {
//                         Id = podcasterAccount.Id,
//                         FullName = podcasterAccount.PodcasterProfileName ?? podcasterAccount.FullName,
//                         Email = podcasterAccount.Email,
//                         MainImageFileKey = podcasterAccount.MainImageFileKey
//                     } : null,

//                     PodcastCategory = show.PodcastCategoryId.HasValue && categories.ContainsKey(show.PodcastCategoryId.Value)
//                         ? new PodcastCategoryDTO
//                         {
//                             Id = categories[show.PodcastCategoryId.Value].Id,
//                             Name = categories[show.PodcastCategoryId.Value].Name,
//                         }
//                         : null,

//                     PodcastSubCategory = show.PodcastSubCategoryId.HasValue && subCategories.ContainsKey(show.PodcastSubCategoryId.Value)
//                         ? new PodcastSubCategoryDTO
//                         {
//                             Id = subCategories[show.PodcastSubCategoryId.Value].Id,
//                             Name = subCategories[show.PodcastSubCategoryId.Value].Name,
//                             PodcastCategoryId = subCategories[show.PodcastSubCategoryId.Value].PodcastCategoryId
//                         }
//                         : null,

//                     PodcastShowSubscriptionType = subscriptionTypes.ContainsKey(show.PodcastShowSubscriptionTypeId)
//                         ? new PodcastShowSubscriptionTypeDTO
//                         {
//                             Id = subscriptionTypes[show.PodcastShowSubscriptionTypeId].Id,
//                             Name = subscriptionTypes[show.PodcastShowSubscriptionTypeId].Name
//                         }
//                         : null,

//                     PodcastChannel = show.PodcastChannelId.HasValue && channels.ContainsKey(show.PodcastChannelId.Value)
//                         ? new PodcastChannelSnippetResponseDTO
//                         {
//                             Id = channels[show.PodcastChannelId.Value].Id,
//                             Name = channels[show.PodcastChannelId.Value].Name,
//                             MainImageFileKey = channels[show.PodcastChannelId.Value].MainImageFileKey
//                         }
//                         : null,

//                     Hashtags = hashtagsByShow.ContainsKey(show.Id)
//                         ? hashtagsByShow[show.Id].Select(h => new HashtagDTO
//                         {
//                             Id = h.Id,
//                             Name = h.Name
//                         }).ToList()
//                         : null,

//                     CurrentStatus = new PodcastShowStatusDTO
//                     {
//                         Id = currentStatus.PodcastShowStatusId,
//                         Name = ((PodcastShowStatusEnum)currentStatus.PodcastShowStatusId).ToString()
//                     }
//                 };

//                 result.Add(item);
//             }

//             return result;
//         }

//         private async Task<List<ChannelListItemResponseDTO>> MapToChannelListItemsAsync(List<PodcastChannel> channels)
//         {
//             var result = new List<ChannelListItemResponseDTO>();

//             // Collect unique IDs
//             var podcasterIds = channels.Select(c => c.PodcasterId).Distinct().ToList();
//             var categoryIds = channels.Where(c => c.PodcastCategoryId.HasValue).Select(c => c.PodcastCategoryId.Value).Distinct().ToList();
//             var subCategoryIds = channels.Where(c => c.PodcastSubCategoryId.HasValue).Select(c => c.PodcastSubCategoryId.Value).Distinct().ToList();

//             // Batch fetch podcasters
//             var podcasterAccounts = new Dictionary<int, AccountStatusCache>();
//             foreach (var id in podcasterIds)
//             {
//                 var account = await _accountCachingService.GetAccountStatusCacheById(id);
//                 if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true) // FIX: Check DeactivatedAt
//                 {
//                     podcasterAccounts[id] = account;
//                 }
//             }

//             // Fetch categories
//             var categories = await _podcastCategoryGenericRepository.FindAll(
//                 predicate: pc => categoryIds.Contains(pc.Id)
//             ).ToDictionaryAsync(pc => pc.Id, pc => pc);

//             // Fetch subcategories
//             var subCategories = await _podcastSubCategoryGenericRepository.FindAll(
//                 predicate: psc => subCategoryIds.Contains(psc.Id)
//             ).ToDictionaryAsync(psc => psc.Id, psc => psc);

//             // Fetch hashtags
//             var channelHashtags = await _podcastChannelHashtagGenericRepository.FindAll(
//                 predicate: pch => channels.Select(c => c.Id).Contains(pch.PodcastChannelId),
//                 includeFunc: q => q.Include(pch => pch.Hashtag)
//             ).ToListAsync();

//             var hashtagsByChannel = channelHashtags
//                 .GroupBy(pch => pch.PodcastChannelId)
//                 .ToDictionary(g => g.Key, g => g.Select(pch => pch.Hashtag).ToList());

//             // Fetch show counts for each channel
//             var showCounts = await _podcastShowGenericRepository.FindAll(
//                 predicate: ps =>
//                     ps.PodcastChannelId.HasValue &&
//                     channels.Select(c => c.Id).Contains(ps.PodcastChannelId.Value) &&
//                     ps.DeletedAt == null,
//                 includeFunc: q => q.Include(ps => ps.PodcastShowStatusTrackings)
//                 .Include(ps => ps.PodcastChannel)
//                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//             )
//             .ToListAsync()
//             .ContinueWith(task =>
//             {
//                 return task.Result
//                     .Where(ps => ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId == (int)PodcastShowStatusEnum.Published &&
//                         (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published)))
//                     .GroupBy(ps => ps.PodcastChannelId.Value)
//                     .ToDictionary(g => g.Key, g => g.Count());
//             });

//             // Map each channel
//             foreach (var channel in channels)
//             {
//                 var podcasterAccount = podcasterAccounts.ContainsKey(channel.PodcasterId)
//                     ? podcasterAccounts[channel.PodcasterId]
//                     : null;

//                 var currentStatus = channel.PodcastChannelStatusTrackings
//                     .OrderByDescending(pst => pst.CreatedAt)
//                     .FirstOrDefault();

//                 var item = new ChannelListItemResponseDTO
//                 {
//                     Id = channel.Id,
//                     Name = channel.Name,
//                     Description = channel.Description,
//                     BackgroundImageFileKey = channel.BackgroundImageFileKey,
//                     MainImageFileKey = channel.MainImageFileKey,
//                     TotalFavorite = channel.TotalFavorite,
//                     ListenCount = channel.ListenCount,
//                     ShowCount = showCounts.ContainsKey(channel.Id) ? showCounts[channel.Id] : 0,
//                     CreatedAt = channel.CreatedAt,
//                     UpdatedAt = channel.UpdatedAt,

//                     Podcaster = podcasterAccount != null ? new AccountSnippetResponseDTO
//                     {
//                         Id = podcasterAccount.Id,
//                         FullName = podcasterAccount.PodcasterProfileName ?? podcasterAccount.FullName,
//                         Email = podcasterAccount.Email,
//                         MainImageFileKey = podcasterAccount.MainImageFileKey
//                     } : null,

//                     PodcastCategory = channel.PodcastCategoryId.HasValue && categories.ContainsKey(channel.PodcastCategoryId.Value)
//                         ? new PodcastCategoryDTO
//                         {
//                             Id = categories[channel.PodcastCategoryId.Value].Id,
//                             Name = categories[channel.PodcastCategoryId.Value].Name,
//                         }
//                         : null,

//                     PodcastSubCategory = channel.PodcastSubCategoryId.HasValue && subCategories.ContainsKey(channel.PodcastSubCategoryId.Value)
//                         ? new PodcastSubCategoryDTO
//                         {
//                             Id = subCategories[channel.PodcastSubCategoryId.Value].Id,
//                             Name = subCategories[channel.PodcastSubCategoryId.Value].Name,
//                             PodcastCategoryId = subCategories[channel.PodcastSubCategoryId.Value].PodcastCategoryId
//                         }
//                         : null,

//                     Hashtags = hashtagsByChannel.ContainsKey(channel.Id)
//                         ? hashtagsByChannel[channel.Id].Select(h => new HashtagDTO
//                         {
//                             Id = h.Id,
//                             Name = h.Name
//                         }).ToList()
//                         : null,

//                     CurrentStatus = new PodcastChannelStatusDTO
//                     {
//                         Id = currentStatus.PodcastChannelStatusId,
//                         Name = ((PodcastChannelStatusEnum)currentStatus.PodcastChannelStatusId).ToString()
//                     }
//                 };

//                 result.Add(item);
//             }

//             return result;
//         }

//         #endregion

//         #region Helper Classes

//         private class CacheMetricsContainer
//         {
//             public PodcasterAllTimeMaxQueryMetric? PodcasterAllTime { get; set; }
//             public PodcasterTemporal7dMaxQueryMetric? PodcasterTemporal { get; set; }
//             public ShowAllTimeMaxQueryMetric? ShowAllTime { get; set; }
//             public ShowTemporal7dMaxQueryMetric? ShowTemporal { get; set; }
//             public ChannelAllTimeMaxQueryMetric? ChannelAllTime { get; set; }
//             public ChannelTemporal7dMaxQueryMetric? ChannelTemporal { get; set; }
//         }

//         #endregion

//         #region Trending Entry Point

//         public async Task<TrendingPodcastFeedDTO> GetTrendingPodcastFeedContentsAsync()
//         {
//             try
//             {
//                 Console.WriteLine("[GetTrendingPodcastFeed] Starting - Anonymous access");

//                 // STEP 1: Load cache metrics (NO user preferences needed)
//                 var cacheMetrics = await LoadTrendingCacheMetricsAsync();
//                 var systemPrefs = await LoadSystemPreferencesAsync();

//                 // STEP 2: Build sections independently (NO deduplication between sections)
//                 var popularPodcasters = await BuildTrendingPopularPodcastersSection(cacheMetrics);

//                 var hotPodcasters = await BuildTrendingHotPodcastersSection(cacheMetrics);

//                 var popularChannels = await BuildTrendingPopularChannelsSection(cacheMetrics);

//                 var hotChannels = await BuildTrendingHotChannelsSection(cacheMetrics);

//                 var popularShows = await BuildTrendingPopularShowsSection(cacheMetrics);

//                 var hotShows = await BuildTrendingHotShowsSection(cacheMetrics);

//                 var newEpisodes = await BuildTrendingNewEpisodesSection();

//                 var popularEpisodes = await BuildTrendingPopularEpisodesSection();

//                 // STEP 3: Build 6 dynamic category sections with stable random
//                 var dynamicCategories = await BuildTrendingDynamicCategorySectionsAsync(systemPrefs, cacheMetrics);

//                 Console.WriteLine("[GetTrendingPodcastFeed] Completed successfully");

//                 return new TrendingPodcastFeedDTO
//                 {
//                     PopularPodcasters = popularPodcasters ?? new TrendingPodcastFeedDTO.PopularPodcastersTrendingPodcastFeedSection{PodcasterList = new List<AccountSnippetResponseDTO>()},
//                     Category1 = dynamicCategories[0] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     HotPodcasters = hotPodcasters ?? new TrendingPodcastFeedDTO.HotPodcastersTrendingPodcastFeedSection{PodcasterList = new List<AccountSnippetResponseDTO>()},
//                     Category2 = dynamicCategories[1] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     PopularChannels = popularChannels ?? new TrendingPodcastFeedDTO.PopularChannelsTrendingPodcastFeedSection{ChannelList = new List<ChannelListItemResponseDTO>()},
//                     Category3 = dynamicCategories[2] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     HotChannels = hotChannels ?? new TrendingPodcastFeedDTO.HotChannelsTrendingPodcastFeedSection{ChannelList = new List<ChannelListItemResponseDTO>()},
//                     Category4 = dynamicCategories[3] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     PopularShows = popularShows ?? new TrendingPodcastFeedDTO.PopularShowsTrendingPodcastFeedSection{ShowList = new List<ShowListItemResponseDTO>()},
//                     Category5 = dynamicCategories[4] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     HotShows = hotShows ?? new TrendingPodcastFeedDTO.HotShowsTrendingPodcastFeedSection{ShowList = new List<ShowListItemResponseDTO>()},
//                     Category6 = dynamicCategories[5] ?? new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection{PodcastCategory = new PodcastCategoryDTO(), ShowList = new List<ShowListItemResponseDTO>()},
//                     NewEpisodes = newEpisodes ?? new TrendingPodcastFeedDTO.NewEpisodesTrendingPodcastFeedSection{EpisodeList = new List<PodcastEpisodeSnippetResponseDTO>()},
//                     PopularEpisodes = popularEpisodes ?? new TrendingPodcastFeedDTO.PopularEpisodesTrendingPodcastFeedSection{EpisodeList = new List<PodcastEpisodeSnippetResponseDTO>()}
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"\n[GetTrendingPodcastFeed] ERROR: {ex.Message}\n{ex.StackTrace}\n");
//                 throw new HttpRequestException("Error while getting trending podcast feed contents: " + ex.Message);
//             }
//         }

//         #endregion

//         #region Trending Cache Loading

//         private async Task<CacheMetricsContainer> LoadTrendingCacheMetricsAsync()
//         {
//             Console.WriteLine("[LoadTrendingCacheMetrics] Loading cache metrics...");

//             var tasks = new List<Task>();
//             PodcasterAllTimeMaxQueryMetric? podcasterAllTime = null;
//             PodcasterTemporal7dMaxQueryMetric? podcasterTemporal = null;
//             ShowAllTimeMaxQueryMetric? showAllTime = null;
//             ShowTemporal7dMaxQueryMetric? showTemporal = null;
//             ChannelAllTimeMaxQueryMetric? channelAllTime = null;
//             ChannelTemporal7dMaxQueryMetric? channelTemporal = null;

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.PodcasterAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 podcasterAllTime = await _redisSharedCacheService.KeyGetAsync<PodcasterAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.PodcasterTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 podcasterTemporal = await _redisSharedCacheService.KeyGetAsync<PodcasterTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ShowAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 showAllTime = await _redisSharedCacheService.KeyGetAsync<ShowAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ShowTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 showTemporal = await _redisSharedCacheService.KeyGetAsync<ShowTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ChannelAllTimeMaxQueryMetricUpdateJob.RedisKeyName;
//                 channelAllTime = await _redisSharedCacheService.KeyGetAsync<ChannelAllTimeMaxQueryMetric>(cacheKey);
//             }));

//             tasks.Add(Task.Run(async () =>
//             {
//                 var cacheKey = _backgroundJobsConfig.ChannelTemporal7dMaxQueryMetricUpdateJob.RedisKeyName;
//                 channelTemporal = await _redisSharedCacheService.KeyGetAsync<ChannelTemporal7dMaxQueryMetric>(cacheKey);
//             }));

//             await Task.WhenAll(tasks);

//             return new CacheMetricsContainer
//             {
//                 PodcasterAllTime = podcasterAllTime,
//                 PodcasterTemporal = podcasterTemporal,
//                 ShowAllTime = showAllTime,
//                 ShowTemporal = showTemporal,
//                 ChannelAllTime = channelAllTime,
//                 ChannelTemporal = channelTemporal
//             };
//         }

//         private async Task<SystemPreferencesTemporal30dQueryMetric?> LoadSystemPreferencesAsync()
//         {
//             var cacheKey = _backgroundJobsConfig.SystemPreferencesTemporal30dQueryMetricUpdateJob.RedisKeyName;
//             return await _redisSharedCacheService.KeyGetAsync<SystemPreferencesTemporal30dQueryMetric>(cacheKey);
//         }

//         #endregion

//         #region Trending Section 1: Popular Podcasters

//         private async Task<TrendingPodcastFeedDTO.PopularPodcastersTrendingPodcastFeedSection?> BuildTrendingPopularPodcastersSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingPopularPodcasters] Building section...");

//                 // Fetch all verified podcasters
//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//             {
//                 new BatchQueryItem
//                 {
//                     Key = "verifiedPodcasters",
//                     QueryType = "findall",
//                     EntityType = "PodcasterProfile",
//                     Parameters = JObject.FromObject(new { IsVerified = true })
//                 }
//             }
//                 };

//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var allPodcasters = result.Results["verifiedPodcasters"].ToObject<List<PodcasterProfileDTO>>();

//                 // Calculate popular scores
//                 var podcastersWithScore = CalculatePodcasterPopularScores(allPodcasters, cacheMetrics.PodcasterAllTime);

//                 var finalPodcasters = podcastersWithScore
//                     .OrderByDescending(x => x.score)
//                     .Take(10)
//                     .Select(x => x.podcaster)
//                     .ToList();

//                 // Fetch full account details
//                 var podcasterListItems = new List<AccountSnippetResponseDTO>();
//                 foreach (var podcaster in finalPodcasters)
//                 {
//                     var account = await _accountCachingService.GetAccountStatusCacheById(podcaster.AccountId);
//                     if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true)
//                     {
//                         podcasterListItems.Add(new AccountSnippetResponseDTO
//                         {
//                             Id = account.Id,
//                             FullName = account.PodcasterProfileName ?? account.FullName,
//                             Email = account.Email,
//                             MainImageFileKey = account.MainImageFileKey
//                         });
//                     }
//                 }

//                 Console.WriteLine($"[TrendingPopularPodcasters] Built with {podcasterListItems.Count} podcasters");

//                 return new TrendingPodcastFeedDTO.PopularPodcastersTrendingPodcastFeedSection
//                 {
//                     PodcasterList = podcasterListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingPopularPodcasters] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 2: Hot Podcasters

//         private async Task<TrendingPodcastFeedDTO.HotPodcastersTrendingPodcastFeedSection?> BuildTrendingHotPodcastersSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingHotPodcasters] Building section...");

//                 // Fetch all verified podcasters
//                 var batchRequest = new BatchQueryRequest
//                 {
//                     Queries = new List<BatchQueryItem>
//             {
//                 new BatchQueryItem
//                 {
//                     Key = "verifiedPodcasters",
//                     QueryType = "findall",
//                     EntityType = "PodcasterProfile",
//                     Parameters = JObject.FromObject(new { IsVerified = true })
//                 }
//             }
//                 };

//                 var result = await _httpServiceQueryClient.ExecuteBatchAsync("UserService", batchRequest);
//                 var allPodcasters = result.Results["verifiedPodcasters"].ToObject<List<PodcasterProfileDTO>>();

//                 // Calculate hot scores
//                 var podcastersWithScore = await CalculatePodcasterHotScoresAsync(allPodcasters, cacheMetrics.PodcasterTemporal);

//                 var finalPodcasters = podcastersWithScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.podcaster)
//                     .ToList();

//                 // Fetch full account details
//                 var podcasterListItems = new List<AccountSnippetResponseDTO>();
//                 foreach (var podcaster in finalPodcasters)
//                 {
//                     var account = await _accountCachingService.GetAccountStatusCacheById(podcaster.AccountId);
//                     if (account != null && account.DeactivatedAt == null && account.HasVerifiedPodcasterProfile == true)
//                     {
//                         podcasterListItems.Add(new AccountSnippetResponseDTO
//                         {
//                             Id = account.Id,
//                             FullName = account.PodcasterProfileName ?? account.FullName,
//                             Email = account.Email,
//                             MainImageFileKey = account.MainImageFileKey
//                         });
//                     }
//                 }

//                 Console.WriteLine($"[TrendingHotPodcasters] Built with {podcasterListItems.Count} podcasters");

//                 return new TrendingPodcastFeedDTO.HotPodcastersTrendingPodcastFeedSection
//                 {
//                     PodcasterList = podcasterListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingHotPodcasters] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 3: Popular Channels

//         private async Task<TrendingPodcastFeedDTO.PopularChannelsTrendingPodcastFeedSection?> BuildTrendingPopularChannelsSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingPopularChannels] Building section...");

//                 // Fetch all channels
//                 var allChannels = await _podcastChannelGenericRepository.FindAll(
//                     predicate: pc => pc.DeletedAt == null,
//                     includeFunc: q => q.Include(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 allChannels = allChannels.Where(pc =>
//                 {
//                     var currentStatus = pc.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId;
//                     return currentStatus == (int)PodcastChannelStatusEnum.Published;
//                 }).ToList();

//                 // Calculate popular scores
//                 var channelsWithScore = CalculateChannelPopularScores(allChannels, cacheMetrics.ChannelAllTime);

//                 var finalChannels = channelsWithScore
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.channel)
//                     .ToList();

//                 var channelListItems = await MapToChannelListItemsAsync(finalChannels);

//                 Console.WriteLine($"[TrendingPopularChannels] Built with {channelListItems.Count} channels");

//                 return new TrendingPodcastFeedDTO.PopularChannelsTrendingPodcastFeedSection
//                 {
//                     ChannelList = channelListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingPopularChannels] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 4: Hot Channels

//         private async Task<TrendingPodcastFeedDTO.HotChannelsTrendingPodcastFeedSection?> BuildTrendingHotChannelsSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingHotChannels] Building section...");

//                 // Fetch all channels
//                 var allChannels = await _podcastChannelGenericRepository.FindAll(
//                     predicate: pc => pc.DeletedAt == null,
//                     includeFunc: q => q.Include(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 allChannels = allChannels.Where(pc =>
//                 {
//                     var currentStatus = pc.PodcastChannelStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastChannelStatusId;
//                     return currentStatus == (int)PodcastChannelStatusEnum.Published;
//                 }).ToList();

//                 // Calculate hot scores
//                 var channelsWithScore = await CalculateChannelHotScoresAsync(allChannels, cacheMetrics.ChannelTemporal);

//                 var finalChannels = channelsWithScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(8)
//                     .Select(x => x.channel)
//                     .ToList();

//                 var channelListItems = await MapToChannelListItemsAsync(finalChannels);

//                 Console.WriteLine($"[TrendingHotChannels] Built with {channelListItems.Count} channels");

//                 return new TrendingPodcastFeedDTO.HotChannelsTrendingPodcastFeedSection
//                 {
//                     ChannelList = channelListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingHotChannels] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 5: Popular Shows

//         private async Task<TrendingPodcastFeedDTO.PopularShowsTrendingPodcastFeedSection?> BuildTrendingPopularShowsSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingPopularShows] Building section...");

//                 // Fetch all shows
//                 var allShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps => ps.DeletedAt == null,
//                     includeFunc: q => q
//                         .Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                             .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 allShows = allShows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                         (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Calculate popular scores
//                 var showsWithScore = CalculateShowPopularScores(allShows, cacheMetrics.ShowAllTime);

//                 var finalShows = showsWithScore
//                     .OrderByDescending(x => x.score)
//                     .Take(12)
//                     .Select(x => x.show)
//                     .ToList();

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[TrendingPopularShows] Built with {showListItems.Count} shows");

//                 return new TrendingPodcastFeedDTO.PopularShowsTrendingPodcastFeedSection
//                 {
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingPopularShows] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 6: Hot Shows

//         private async Task<TrendingPodcastFeedDTO.HotShowsTrendingPodcastFeedSection?> BuildTrendingHotShowsSection(
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingHotShows] Building section...");

//                 // Fetch all shows
//                 var allShows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps => ps.DeletedAt == null,
//                     includeFunc: q => q
//                         .Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                             .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 allShows = allShows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                         (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Calculate hot scores
//                 var showsWithScore = await CalculateShowHotScoresAsync(allShows, cacheMetrics.ShowTemporal);

//                 var finalShows = showsWithScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(10)
//                     .Select(x => x.show)
//                     .ToList();

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[TrendingHotShows] Built with {showListItems.Count} shows");

//                 return new TrendingPodcastFeedDTO.HotShowsTrendingPodcastFeedSection
//                 {
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingHotShows] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 7: New Episodes

//         private async Task<TrendingPodcastFeedDTO.NewEpisodesTrendingPodcastFeedSection?> BuildTrendingNewEpisodesSection()
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingNewEpisodes] Building section...");

//                 var now = _dateHelper.GetNowByAppTimeZone();
//                 var twoDaysAgo = now.AddDays(-2);

//                 // Query episodes published in last 2 days
//                 var episodes = await _podcastEpisodeGenericRepository.FindAll(
//                     predicate: pe =>
//                         pe.DeletedAt == null &&
//                         pe.PodcastShow.DeletedAt == null,
//                     includeFunc: q => q
//                         .Include(pe => pe.PodcastEpisodeStatusTrackings)
//                         .Include(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastShowStatusTrackings)
//                         .Include(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastChannel)
//                                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by recent published tracking
//                 var recentEpisodes = episodes.Where(pe =>
//                 {
//                     var publishedTracking = pe.PodcastEpisodeStatusTrackings
//                         .Where(t => t.PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published)
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault();

//                     if (publishedTracking == null || publishedTracking.CreatedAt < twoDaysAgo)
//                         return false;

//                     var showStatus = pe.PodcastShow.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;

//                     var channelStatus = pe.PodcastShow.PodcastChannel == null ? (int?)null :
//                         pe.PodcastShow.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId;

//                     return showStatus == (int)PodcastShowStatusEnum.Published &&
//                            (channelStatus == null || channelStatus == (int)PodcastChannelStatusEnum.Published);
//                 })
//                 .OrderByDescending(pe => pe.PodcastEpisodeStatusTrackings
//                     .Where(t => t.PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published)
//                     .Max(t => t.CreatedAt))
//                 .ToList();

//                 // Fallback: extend to 7 days if less than 15
//                 if (recentEpisodes.Count < 15)
//                 {
//                     var sevenDaysAgo = now.AddDays(-7);
//                     var fallbackEpisodes = episodes.Where(pe =>
//                     {
//                         var publishedTracking = pe.PodcastEpisodeStatusTrackings
//                             .Where(t => t.PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published)
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault();

//                         if (publishedTracking == null || publishedTracking.CreatedAt < sevenDaysAgo)
//                             return false;

//                         var showStatus = pe.PodcastShow.PodcastShowStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastShowStatusId;

//                         var channelStatus = pe.PodcastShow.PodcastChannel == null ? (int?)null :
//                             pe.PodcastShow.PodcastChannel.PodcastChannelStatusTrackings
//                                 .OrderByDescending(t => t.CreatedAt)
//                                 .FirstOrDefault()?.PodcastChannelStatusId;

//                         return showStatus == (int)PodcastShowStatusEnum.Published &&
//                                (channelStatus == null || channelStatus == (int)PodcastChannelStatusEnum.Published);
//                     })
//                     .OrderByDescending(pe => pe.PodcastEpisodeStatusTrackings
//                         .Where(t => t.PodcastEpisodeStatusId == (int)PodcastEpisodeStatusEnum.Published)
//                         .Max(t => t.CreatedAt))
//                     .ToList();

//                     recentEpisodes = fallbackEpisodes.Take(15).ToList();
//                 }

//                 var finalEpisodes = recentEpisodes.Take(15).ToList();

//                 var episodeListItems = finalEpisodes.Select(ep => new PodcastEpisodeSnippetResponseDTO
//                 {
//                     Id = ep.Id,
//                     Name = ep.Name,
//                     MainImageFileKey = ep.MainImageFileKey,
//                     IsReleased = ep.IsReleased,
//                     ReleaseDate = ep.ReleaseDate
//                 }).ToList();

//                 Console.WriteLine($"[TrendingNewEpisodes] Built with {episodeListItems.Count} episodes");

//                 return new TrendingPodcastFeedDTO.NewEpisodesTrendingPodcastFeedSection
//                 {
//                     EpisodeList = episodeListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingNewEpisodes] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 8: Popular Episodes

//         private async Task<TrendingPodcastFeedDTO.PopularEpisodesTrendingPodcastFeedSection?> BuildTrendingPopularEpisodesSection()
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingPopularEpisodes] Building section...");

//                 // Part A: Top all-time (70% = 10 episodes)
//                 var allEpisodes = await _podcastEpisodeGenericRepository.FindAll(
//                     predicate: pe =>
//                         pe.DeletedAt == null &&
//                         pe.PodcastShow.DeletedAt == null &&
//                         pe.ListenCount > 0,
//                     includeFunc: q => q
//                         .Include(pe => pe.PodcastEpisodeStatusTrackings)
//                         .Include(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastShowStatusTrackings)
//                         .Include(pe => pe.PodcastShow)
//                             .ThenInclude(ps => ps.PodcastChannel)
//                                 .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 var publishedEpisodes = allEpisodes.Where(pe =>
//                 {
//                     var episodeStatus = pe.PodcastEpisodeStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastEpisodeStatusId;

//                     var showStatus = pe.PodcastShow.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;

//                     var channelStatus = pe.PodcastShow.PodcastChannel == null ? (int?)null :
//                         pe.PodcastShow.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId;

//                     return episodeStatus == (int)PodcastEpisodeStatusEnum.Published &&
//                            showStatus == (int)PodcastShowStatusEnum.Published &&
//                            (channelStatus == null || channelStatus == (int)PodcastChannelStatusEnum.Published);
//                 }).ToList();

//                 var partAEpisodes = publishedEpisodes
//                     .OrderByDescending(pe => pe.ListenCount)
//                     .Take(10)
//                     .ToList();

//                 // Part B: Diversity fallback (30% = 5 episodes from different shows)
//                 var partAShowIds = partAEpisodes.Select(ep => ep.PodcastShowId).ToHashSet();

//                 var partBEpisodes = publishedEpisodes
//                     .Where(pe => !partAShowIds.Contains(pe.PodcastShowId))
//                     .OrderByDescending(pe => pe.ListenCount)
//                     .Take(5)
//                     .ToList();

//                 var finalEpisodes = partAEpisodes.Concat(partBEpisodes).Take(15).ToList();

//                 var episodeListItems = finalEpisodes.Select(ep => new PodcastEpisodeSnippetResponseDTO
//                 {
//                     Id = ep.Id,
//                     Name = ep.Name,
//                     MainImageFileKey = ep.MainImageFileKey,
//                     IsReleased = ep.IsReleased,
//                     ReleaseDate = ep.ReleaseDate
//                 }).ToList();

//                 Console.WriteLine($"[TrendingPopularEpisodes] Built with {episodeListItems.Count} episodes (A:{partAEpisodes.Count}, B:{partBEpisodes.Count})");

//                 return new TrendingPodcastFeedDTO.PopularEpisodesTrendingPodcastFeedSection
//                 {
//                     EpisodeList = episodeListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingPopularEpisodes] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion

//         #region Trending Section 9-14: Dynamic Categories

//         private async Task<List<TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection?>> BuildTrendingDynamicCategorySectionsAsync(
//             SystemPreferencesTemporal30dQueryMetric? systemPrefs,
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine("[TrendingDynamicCategories] Building 6 dynamic category sections...");

//                 // Select 6 stable random categories
//                 var selectedCategories = SelectStableRandomCategories(systemPrefs);

//                 if (selectedCategories == null || selectedCategories.Count == 0)
//                 {
//                     Console.WriteLine("[TrendingDynamicCategories] No categories available");
//                     return Enumerable.Range(0, 6).Select(_ => (TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection?)null).ToList();
//                 }

//                 var results = new List<TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection?>();

//                 foreach (var category in selectedCategories)
//                 {
//                     var section = await BuildSingleDynamicCategorySection(category, cacheMetrics);
//                     results.Add(section);
//                 }

//                 // FIX: Ensure we always return exactly 6 elements, fill with null if needed
//                 while (results.Count < 6)
//                 {
//                     results.Add(null);
//                 }

//                 Console.WriteLine($"[TrendingDynamicCategories] Built {results.Count} category sections (actual: {selectedCategories.Count})");
//                 return results;
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[TrendingDynamicCategories] ERROR: {ex.Message}");
//                 return Enumerable.Range(0, 6).Select(_ => (TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection?)null).ToList();
//             }
//         }

//         private List<PodcastCategory> SelectStableRandomCategories(SystemPreferencesTemporal30dQueryMetric? systemPrefs)
//         {
//             if (systemPrefs?.ListenedPodcastCategories == null || !systemPrefs.ListenedPodcastCategories.Any())
//             {
//                 Console.WriteLine("[SelectStableRandomCategories] No system preferences available");
//                 return new List<PodcastCategory>();
//             }

//             // Get top 10 trending categories
//             var top10CategoryIds = systemPrefs.ListenedPodcastCategories
//                 .OrderByDescending(c => c.ListenCount)
//                 .Take(10)
//                 .Select(c => c.PodcastCategoryId)
//                 .ToList();

//             // Calculate stable seed based on 6-hour window
//             var now = _dateHelper.GetNowByAppTimeZone();
//             var seed = (int)Math.Floor(now.Hour / 6.0);

//             // Use seed to create stable random selection
//             var random = new Random(seed + now.Year * 10000 + now.DayOfYear * 100);

//             // Shuffle and take 6
//             var selectedIds = top10CategoryIds
//                 .OrderBy(x => random.Next())
//                 .Take(6)
//                 .ToList();

//             // Fetch category entities
//             var categories = _podcastCategoryGenericRepository.FindAll(
//                 predicate: pc => selectedIds.Contains(pc.Id)
//             ).ToList();

//             Console.WriteLine($"[SelectStableRandomCategories] Selected {categories.Count} categories (seed={seed})");
//             return categories;
//         }

//         private async Task<TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection?> BuildSingleDynamicCategorySection(
//             PodcastCategory category,
//             CacheMetricsContainer cacheMetrics)
//         {
//             try
//             {
//                 Console.WriteLine($"[DynamicCategory-{category.Id}] Building section for '{category.Name}'...");

//                 // Fetch all shows in category
//                 var shows = await _podcastShowGenericRepository.FindAll(
//                     predicate: ps =>
//                         ps.PodcastCategoryId == category.Id &&
//                         ps.DeletedAt == null,
//                     includeFunc: q => q
//                         .Include(ps => ps.PodcastShowStatusTrackings)
//                         .Include(ps => ps.PodcastChannel)
//                             .ThenInclude(pc => pc.PodcastChannelStatusTrackings)
//                 ).ToListAsync();

//                 // Filter by Published status
//                 shows = shows.Where(ps =>
//                 {
//                     var currentStatus = ps.PodcastShowStatusTrackings
//                         .OrderByDescending(t => t.CreatedAt)
//                         .FirstOrDefault()?.PodcastShowStatusId;
//                     return currentStatus == (int)PodcastShowStatusEnum.Published &&
//                         (ps.PodcastChannel == null || (ps.PodcastChannel.DeletedAt == null && ps.PodcastChannel.PodcastChannelStatusTrackings
//                             .OrderByDescending(t => t.CreatedAt)
//                             .FirstOrDefault()?.PodcastChannelStatusId == (int)PodcastChannelStatusEnum.Published));
//                 }).ToList();

//                 // Part A (40%): 4 hot shows
//                 var showsWithHotScore = await CalculateShowHotScoresAsync(shows, cacheMetrics.ShowTemporal);

//                 var partAShows = showsWithHotScore
//                     .Where(x => x.score > 0)
//                     .OrderByDescending(x => x.score)
//                     .Take(4)
//                     .Select(x => x.show)
//                     .ToList();

//                 // Part B (60%): 6 popular shows
//                 var existingIds = partAShows.Select(s => s.Id).ToHashSet();
//                 var showsWithPopularScore = CalculateShowPopularScores(
//                     shows.Where(s => !existingIds.Contains(s.Id)).ToList(),
//                     cacheMetrics.ShowAllTime
//                 );

//                 var needed = 4 - partAShows.Count;
//                 var partBShows = showsWithPopularScore
//                     .OrderByDescending(x => x.score)
//                     .Take(6 + needed)
//                     .Select(x => x.show)
//                     .ToList();

//                 var finalShows = partAShows.Concat(partBShows).Take(10).ToList();

//                 var showListItems = await MapToShowListItemsAsync(finalShows);

//                 Console.WriteLine($"[DynamicCategory-{category.Id}] Built with {showListItems.Count} shows (A:{partAShows.Count}, B:{partBShows.Count})");

//                 // Return proper DTO type
//                 return new TrendingPodcastFeedDTO.CategoryTrendingPodcastFeedSection
//                 {
//                     PodcastCategory = new PodcastCategoryDTO
//                     {
//                         Id = category.Id,
//                         Name = category.Name
//                     },
//                     ShowList = showListItems
//                 };
//             }
//             catch (Exception ex)
//             {
//                 Console.WriteLine($"[DynamicCategory-{category.Id}] ERROR: {ex.Message}");
//                 return null;
//             }
//         }

//         #endregion
//     }
// }